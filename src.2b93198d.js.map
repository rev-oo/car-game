{"version":3,"sources":["src/scripts/inputHandler.ts","src/scripts/game.ts","src/scripts/map/floor.ts","node_modules/sat/SAT.js","src/scripts/map/house.ts","src/scripts/map/map.ts","src/scripts/map/road.ts","src/scripts/map/wall.ts","src/scripts/map/terrain.ts","src/scripts/map/trafficSinalStates.ts","src/scripts/map/trafficSignal.ts","src/scripts/mapBuilder.ts","src/scripts/utils.ts","src/scripts/particle/particle.ts","src/scripts/particle/smoke.ts","src/scripts/car/carStates.ts","src/scripts/car/car.ts","src/scripts/goal.ts","src/index.ts"],"names":[],"mappings":";;;AAEA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,IAAA,EAAA,WAGE,SAAA,IAAA,IAAA,EAAA,KACE,KAAK,KAAO,GAEZ,IAAM,EAAO,CAAC,YAAa,UAAW,YAAa,aAAc,QAAS,aAC1E,OAAO,iBAAiB,UAAW,SAAC,GAC9B,EAAK,SAAS,EAAE,OAAS,EAAK,KAAK,SAAS,EAAE,MAChD,EAAK,KAAK,KAAK,EAAE,OAGrB,OAAO,iBAAiB,QAAS,SAAC,GAC5B,EAAK,KAAK,SAAS,EAAE,MACvB,EAAK,KAAK,OAAO,EAAK,KAAK,QAAQ,EAAE,KAAM,KAQnD,OAHS,EAAA,UAAA,QAAP,WACE,OAAO,KAAK,MAEhB,EAtBA,GAAA,QAAA,QAAA;;ACIA,aAAA,IAAA,EAAA,MAAA,KAAA,iBAAA,SAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,IAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAJA,IAAA,EAAA,EAAA,QAAA,mBAIA,EAAA,WAWE,SAAA,EAAY,EAAe,GALnB,KAAA,UAAwB,GAEzB,KAAA,KAAe,EACf,KAAA,UAAoB,EAGzB,KAAK,MAAQ,EACb,KAAK,OAAS,EACd,KAAK,IAAM,KACX,KAAK,IAAM,KACX,KAAK,KAAO,KACZ,KAAK,aAAe,IAAI,EAAA,QAkE5B,OA/DS,EAAA,UAAA,OAAP,SAAc,GACZ,KAAK,IAAM,GAGN,EAAA,UAAA,OAAP,SAAc,GACZ,KAAK,IAAM,GAGN,EAAA,UAAA,QAAP,SAAe,GACb,KAAK,KAAO,GAGP,EAAA,UAAA,YAAP,SAAoB,GAClB,KAAK,UAAU,KAAK,IAGf,EAAA,UAAA,OAAP,SAAc,GACZ,KAAK,iBACL,KAAK,WAED,KAAK,KACP,KAAK,IAAI,OAAO,GAEd,KAAK,KACP,KAAK,IAAI,OAAO,KAAK,aAAa,UAAW,GAE/C,KAAK,UAAU,QAAQ,SAAC,GACtB,EAAS,WAGX,KAAK,UAAY,KAAK,UAAU,OAAO,SAAA,GAAY,OAAC,EAAS,qBAGxD,EAAA,UAAA,KAAP,SAAY,GACN,KAAK,KACP,KAAK,IAAI,KAAK,GAEZ,KAAK,MACP,KAAK,KAAK,KAAK,GAEb,KAAK,KACP,KAAK,IAAI,KAAK,GAEhB,KAAK,UAAU,QAAQ,SAAC,GACtB,EAAS,KAAK,MAIX,EAAA,UAAA,eAAP,WApEF,IAAA,EAqEQ,KAAK,MACK,QAAR,EAAA,KAAK,WAAG,IAAA,OAAA,EAAA,EAAE,eAAe,KAAK,IAAI,YACpC,KAAK,UAAW,EAChB,MAAM,aAKL,EAAA,UAAA,SAAP,WACM,KAAK,KAAO,KAAK,MAAQ,KAAK,KAAK,SAAS,KAAK,OACnD,KAAK,KAAM,EACX,MAAM,SAGZ,EAnFA,GAAA,QAAA,QAAA;;ACNA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,IAAA,EAAA,WAOE,SAAA,EAAY,EAAW,EAAW,EAAe,EAAgB,GAC/D,KAAK,EAAI,EACT,KAAK,EAAI,EACT,KAAK,MAAQ,EACb,KAAK,OAAS,EACd,KAAK,MAAQ,EAOjB,OAJS,EAAA,UAAA,KAAP,SAAY,GACV,EAAQ,UAAY,KAAK,MACzB,EAAQ,SAAS,KAAK,EAAG,KAAK,EAAG,KAAK,MAAO,KAAK,SAEtD,EAnBA,GAAA,QAAA,QAAA;;;ACkiCA,IAAA,GAzgCA,SAAA,EAAA,GACA,aACA,mBAAA,GAAA,EAAA,IACA,EAAA,GACA,iBAAA,QACA,OAAA,QAAA,IAEA,EAAA,IAAA,IAPA,CASA,KAAA,WACA,aAEA,IAAA,EAAA,GAeA,SAAA,EAAA,EAAA,GACA,KAAA,EAAA,GAAA,EACA,KAAA,EAAA,GAAA,EA0MA,SAAA,EAAA,EAAA,GACA,KAAA,IAAA,GAAA,IAAA,EACA,KAAA,EAAA,GAAA,EACA,KAAA,OAAA,IAAA,EAuDA,SAAA,EAAA,EAAA,GACA,KAAA,IAAA,GAAA,IAAA,EACA,KAAA,MAAA,EACA,KAAA,OAAA,IAAA,EACA,KAAA,UAAA,GAAA,IA4OA,SAAA,EAAA,EAAA,EAAA,GACA,KAAA,IAAA,GAAA,IAAA,EACA,KAAA,EAAA,GAAA,EACA,KAAA,EAAA,GAAA,EA6BA,SAAA,IACA,KAAA,EAAA,KACA,KAAA,EAAA,KACA,KAAA,SAAA,IAAA,EACA,KAAA,SAAA,IAAA,EACA,KAAA,QAvhBA,EAAA,OAAA,EAEA,EAAA,EAAA,EAQA,EAAA,UAAA,KAAA,EAAA,UAAA,KAAA,SAAA,GAGA,OAFA,KAAA,EAAA,EAAA,EACA,KAAA,EAAA,EAAA,EACA,MAOA,EAAA,UAAA,MAAA,EAAA,UAAA,MAAA,WACA,OAAA,IAAA,EAAA,KAAA,EAAA,KAAA,IAQA,EAAA,UAAA,KAAA,EAAA,UAAA,KAAA,WACA,IAAA,EAAA,KAAA,EAGA,OAFA,KAAA,EAAA,KAAA,EACA,KAAA,GAAA,EACA,MAQA,EAAA,UAAA,OAAA,EAAA,UAAA,OAAA,SAAA,GACA,IAAA,EAAA,KAAA,EACA,EAAA,KAAA,EAGA,OAFA,KAAA,EAAA,EAAA,KAAA,IAAA,GAAA,EAAA,KAAA,IAAA,GACA,KAAA,EAAA,EAAA,KAAA,IAAA,GAAA,EAAA,KAAA,IAAA,GACA,MAOA,EAAA,UAAA,QAAA,EAAA,UAAA,QAAA,WAGA,OAFA,KAAA,GAAA,KAAA,EACA,KAAA,GAAA,KAAA,EACA,MAQA,EAAA,UAAA,UAAA,EAAA,UAAA,UAAA,WACA,IAAA,EAAA,KAAA,MAKA,OAJA,EAAA,IACA,KAAA,EAAA,KAAA,EAAA,EACA,KAAA,EAAA,KAAA,EAAA,GAEA,MAQA,EAAA,UAAA,IAAA,EAAA,UAAA,IAAA,SAAA,GAGA,OAFA,KAAA,GAAA,EAAA,EACA,KAAA,GAAA,EAAA,EACA,MAQA,EAAA,UAAA,IAAA,EAAA,UAAA,IAAA,SAAA,GAGA,OAFA,KAAA,GAAA,EAAA,EACA,KAAA,GAAA,EAAA,EACA,MAWA,EAAA,UAAA,MAAA,EAAA,UAAA,MAAA,SAAA,EAAA,GAGA,OAFA,KAAA,GAAA,EACA,KAAA,QAAA,IAAA,EAAA,EAAA,EACA,MAQA,EAAA,UAAA,QAAA,EAAA,UAAA,QAAA,SAAA,GACA,IAAA,EAAA,KAAA,IAAA,GAAA,EAAA,OAGA,OAFA,KAAA,EAAA,EAAA,EAAA,EACA,KAAA,EAAA,EAAA,EAAA,EACA,MASA,EAAA,UAAA,SAAA,EAAA,UAAA,SAAA,SAAA,GACA,IAAA,EAAA,KAAA,IAAA,GAGA,OAFA,KAAA,EAAA,EAAA,EAAA,EACA,KAAA,EAAA,EAAA,EAAA,EACA,MAQA,EAAA,UAAA,QAAA,EAAA,UAAA,QAAA,SAAA,GACA,IAAA,EAAA,KAAA,EACA,EAAA,KAAA,EAIA,OAHA,KAAA,QAAA,GAAA,MAAA,GACA,KAAA,GAAA,EACA,KAAA,GAAA,EACA,MASA,EAAA,UAAA,SAAA,EAAA,UAAA,SAAA,SAAA,GACA,IAAA,EAAA,KAAA,EACA,EAAA,KAAA,EAIA,OAHA,KAAA,SAAA,GAAA,MAAA,GACA,KAAA,GAAA,EACA,KAAA,GAAA,EACA,MAQA,EAAA,UAAA,IAAA,EAAA,UAAA,IAAA,SAAA,GACA,OAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,GAOA,EAAA,UAAA,KAAA,EAAA,UAAA,KAAA,WACA,OAAA,KAAA,IAAA,OAOA,EAAA,UAAA,IAAA,EAAA,UAAA,IAAA,WACA,OAAA,KAAA,KAAA,KAAA,SAoBA,EAAA,OAAA,EAQA,EAAA,UAAA,aAAA,EAAA,UAAA,aAAA,WACA,IAAA,EAAA,KAAA,EAEA,OAAA,IAAA,EADA,KAAA,IAAA,QAAA,IAAA,KAAA,QAAA,IAAA,IAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,IASA,EAAA,UAAA,QAAA,EAAA,UAAA,QAAA,WACA,OAAA,KAAA,eAAA,aAQA,EAAA,UAAA,UAAA,EAAA,UAAA,UAAA,SAAA,GAEA,OADA,KAAA,OAAA,EACA,MA4BA,EAAA,QAAA,EAaA,EAAA,UAAA,UAAA,EAAA,UAAA,UAAA,SAAA,GAGA,IADA,KAAA,QAAA,KAAA,OAAA,SAAA,EAAA,OACA,CACA,IAAA,EACA,EAAA,KAAA,WAAA,GACA,EAAA,KAAA,MAAA,GACA,EAAA,KAAA,QAAA,GAEA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAEA,IAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GACA,IAAA,GAAA,EAAA,IAAA,EAAA,GAAA,EAAA,IAAA,EAAA,GAKA,EAAA,KAAA,IAAA,GACA,EAAA,KAAA,IAAA,GACA,EAAA,KAAA,IAAA,KANA,EAAA,OAAA,EAAA,GACA,GAAA,IAUA,OAFA,KAAA,OAAA,EACA,KAAA,UACA,MAQA,EAAA,UAAA,SAAA,EAAA,UAAA,SAAA,SAAA,GAGA,OAFA,KAAA,MAAA,EACA,KAAA,UACA,MAQA,EAAA,UAAA,UAAA,EAAA,UAAA,UAAA,SAAA,GAGA,OAFA,KAAA,OAAA,EACA,KAAA,UACA,MAUA,EAAA,UAAA,OAAA,EAAA,UAAA,OAAA,SAAA,GAGA,IAFA,IAAA,EAAA,KAAA,OACA,EAAA,EAAA,OACA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,GAAA,OAAA,GAGA,OADA,KAAA,UACA,MAeA,EAAA,UAAA,UAAA,EAAA,UAAA,UAAA,SAAA,EAAA,GAGA,IAFA,IAAA,EAAA,KAAA,OACA,EAAA,EAAA,OACA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,GAAA,GAAA,EACA,EAAA,GAAA,GAAA,EAGA,OADA,KAAA,UACA,MASA,EAAA,UAAA,QAAA,WAGA,IAcA,EAdA,EAAA,KAAA,WAIA,EAAA,KAAA,MAIA,EAAA,KAAA,QAEA,EAAA,KAAA,OACA,EAAA,KAAA,OACA,EAAA,KAAA,MACA,EAAA,EAAA,OAEA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,IAAA,EAAA,EAAA,GAAA,KAAA,EAAA,IACA,EAAA,GAAA,EAAA,EACA,EAAA,GAAA,EAAA,EACA,IAAA,GACA,EAAA,OAAA,GAIA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,IAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GACA,EAAA,EAAA,GAAA,KAAA,GAAA,IAAA,GACA,EAAA,GAAA,KAAA,GAAA,OAAA,YAEA,OAAA,MAWA,EAAA,UAAA,aAAA,EAAA,UAAA,aAAA,WAOA,IANA,IAAA,EAAA,KAAA,WACA,EAAA,EAAA,OACA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,IAAA,EAAA,EAAA,GACA,EAAA,EAAA,EACA,EAAA,EAAA,EAEA,EAAA,EAAA,IACA,EAAA,EAAA,GAEA,EAAA,EAAA,EACA,EAAA,EAAA,EAEA,EAAA,EAAA,IACA,EAAA,EAAA,GAGA,OAAA,IAAA,EAAA,KAAA,IAAA,QAAA,IAAA,IAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,IAWA,EAAA,UAAA,QAAA,EAAA,UAAA,QAAA,WACA,OAAA,KAAA,eAAA,aAYA,EAAA,UAAA,YAAA,EAAA,UAAA,YAAA,WAMA,IALA,IAAA,EAAA,KAAA,WACA,EAAA,EAAA,OACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,IAAA,EAAA,EAAA,GACA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,IAAA,EAAA,EAAA,EAAA,GAAA,EACA,IAAA,EAAA,EAAA,EAAA,GAAA,EACA,GAAA,EAKA,OAAA,IAAA,EAFA,GADA,GAAA,EAEA,GAAA,IAwBA,EAAA,IAAA,EAMA,EAAA,UAAA,UAAA,EAAA,UAAA,UAAA,WACA,IAAA,EAAA,KAAA,IACA,EAAA,KAAA,EACA,EAAA,KAAA,EACA,OAAA,IAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,CACA,IAAA,EAAA,IAAA,EAAA,EAAA,GACA,IAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EAAA,MAsBA,EAAA,SAAA,EAQA,EAAA,UAAA,MAAA,EAAA,UAAA,MAAA,WAIA,OAHA,KAAA,MAAA,EACA,KAAA,MAAA,EACA,KAAA,QAAA,OAAA,UACA,MAWA,IADA,IAAA,EAAA,GACA,EAAA,EAAA,EAAA,GAAA,IAAA,EAAA,KAAA,IAAA,GAOA,IAAA,EAAA,GACA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,KAAA,IAMA,IAAA,EAAA,IAAA,EAMA,EAAA,IAAA,EAAA,IAAA,EAAA,KAAA,MAAA,YAcA,SAAA,EAAA,EAAA,EAAA,GAIA,IAHA,IAAA,EAAA,OAAA,UACA,GAAA,OAAA,UACA,EAAA,EAAA,OACA,EAAA,EAAA,EAAA,EAAA,IAAA,CAEA,IAAA,EAAA,EAAA,GAAA,IAAA,GACA,EAAA,IAAA,EAAA,GACA,EAAA,IAAA,EAAA,GAEA,EAAA,GAAA,EAAA,EAAA,GAAA,EAkBA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,IAAA,EAAA,EAAA,MACA,EAAA,EAAA,MAEA,EAAA,EAAA,MAAA,KAAA,GAAA,IAAA,GACA,EAAA,EAAA,IAAA,GAQA,GANA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,GAEA,EAAA,IAAA,EACA,EAAA,IAAA,EAEA,EAAA,GAAA,EAAA,IAAA,EAAA,GAAA,EAAA,GAIA,OAHA,EAAA,KAAA,GACA,EAAA,KAAA,GACA,EAAA,KAAA,IACA,EAGA,GAAA,EAAA,CACA,IAuBA,EACA,EAxBA,EAAA,EAEA,GAAA,EAAA,GAAA,EAAA,GAGA,GAFA,EAAA,MAAA,EAEA,EAAA,GAAA,EAAA,GACA,EAAA,EAAA,GAAA,EAAA,GACA,EAAA,MAAA,OAKA,GAFA,EAAA,EAAA,GAAA,EAAA,KACA,EAAA,EAAA,GAAA,EAAA,IACA,GAAA,OAMA,GAFA,EAAA,MAAA,EAEA,EAAA,GAAA,EAAA,GACA,EAAA,EAAA,GAAA,EAAA,GACA,EAAA,MAAA,OAKA,GAFA,EAAA,EAAA,GAAA,EAAA,KACA,EAAA,EAAA,GAAA,EAAA,IACA,GAAA,EAIA,IAAA,EAAA,KAAA,IAAA,GACA,EAAA,EAAA,UACA,EAAA,QAAA,EACA,EAAA,SAAA,KAAA,GACA,EAAA,GACA,EAAA,SAAA,WAOA,OAHA,EAAA,KAAA,GACA,EAAA,KAAA,GACA,EAAA,KAAA,IACA,EAiBA,SAAA,EAAA,EAAA,GACA,IAAA,EAAA,EAAA,OACA,EAAA,EAAA,IAAA,GAGA,OAAA,EAAA,EAAA,EAGA,EAAA,EAAA,EAEA,EAzBA,EAAA,iBAAA,EA+BA,IAAA,GAAA,EAIA,EAAA,EAIA,EAAA,EAiFA,SAAA,EAAA,EAAA,EAAA,GAWA,IATA,IAAA,EAAA,EAAA,MAAA,KAAA,EAAA,KAAA,IAAA,EAAA,QAAA,IAAA,EAAA,KACA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,EAAA,WACA,EAAA,EAAA,OACA,EAAA,EAAA,MACA,EAAA,EAAA,MAGA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,IAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EACA,EAAA,KAGA,EAAA,KAAA,EAAA,MAAA,IAEA,EAAA,KAAA,GAAA,IAAA,EAAA,IAKA,GAAA,EAAA,OAAA,IACA,EAAA,MAAA,GAIA,IAAA,EAAA,EAAA,EAAA,GAEA,GAAA,IAAA,EAAA,CAEA,EAAA,KAAA,EAAA,MAAA,IAEA,IAAA,EAAA,EAAA,MAAA,KAAA,GAAA,IAAA,EAAA,IAEA,IADA,EAAA,EAAA,EAAA,MACA,EAAA,CAGA,IADA,EAAA,EAAA,OACA,EAMA,OAJA,EAAA,KAAA,GACA,EAAA,KAAA,GACA,EAAA,KAAA,GACA,EAAA,KAAA,IACA,EACA,IAEA,EAAA,MAAA,EACA,EAAA,EAAA,YACA,EAAA,EAAA,GAGA,EAAA,KAAA,QAEA,GAAA,IAAA,GAMA,GAJA,EAAA,KAAA,EAAA,MAAA,IAEA,EAAA,KAAA,GAAA,IAAA,EAAA,KACA,EAAA,EAAA,EAAA,MACA,EAAA,CAGA,IADA,EAAA,EAAA,OACA,EAKA,OAHA,EAAA,KAAA,GACA,EAAA,KAAA,GACA,EAAA,KAAA,IACA,EACA,IAEA,EAAA,MAAA,EACA,EAAA,EAAA,YACA,EAAA,EAAA,QAIA,CAGA,IAAA,EAAA,EAAA,OAAA,YAGA,EAAA,EAAA,IAAA,GACA,EAAA,KAAA,IAAA,GAEA,GAAA,EAAA,GAAA,EAAA,EAKA,OAHA,EAAA,KAAA,GACA,EAAA,KAAA,GACA,EAAA,KAAA,IACA,EACA,IAEA,EAAA,EACA,EAAA,EAAA,GAGA,GAAA,GAAA,EAAA,EAAA,KACA,EAAA,MAAA,IAOA,GAAA,GAAA,KAAA,IAAA,GAAA,KAAA,IAAA,EAAA,WACA,EAAA,QAAA,EACA,EAAA,SAAA,KAAA,IAaA,OARA,IACA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,SAAA,KAAA,EAAA,UAAA,MAAA,EAAA,UAEA,EAAA,KAAA,GACA,EAAA,KAAA,GACA,EAAA,KAAA,IACA,EAyCA,SAAA,EAAA,EAAA,EAAA,GAMA,IALA,IAAA,EAAA,EAAA,WACA,EAAA,EAAA,OACA,EAAA,EAAA,WACA,EAAA,EAAA,OAEA,EAAA,EAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,IAAA,EAAA,IAAA,EAAA,EAAA,EAAA,QAAA,GAAA,GACA,OAAA,EAIA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,IAAA,EAAA,IAAA,EAAA,EAAA,EAAA,QAAA,GAAA,GACA,OAAA,EAWA,OALA,IACA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,SAAA,KAAA,EAAA,UAAA,MAAA,EAAA,WAEA,EAIA,OAjQA,EAAA,cARA,SAAA,EAAA,GACA,IAAA,EAAA,EAAA,MAAA,KAAA,GAAA,IAAA,EAAA,KAAA,IAAA,EAAA,QACA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,OAGA,OAFA,EAAA,KAAA,GAEA,GAAA,GAmBA,EAAA,eATA,SAAA,EAAA,GACA,EAAA,IAAA,KAAA,GACA,EAAA,QACA,IAAA,EAAA,EAAA,EAAA,EAAA,GAIA,OAHA,IACA,EAAA,EAAA,MAEA,GAsCA,EAAA,iBA1BA,SAAA,EAAA,EAAA,GAGA,IAAA,EAAA,EAAA,MAAA,KAAA,EAAA,KAAA,IAAA,EAAA,QAAA,IAAA,EAAA,KAAA,IAAA,EAAA,QACA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,EAAA,OAEA,GAAA,EAAA,EAEA,OADA,EAAA,KAAA,IACA,EAGA,GAAA,EAAA,CACA,IAAA,EAAA,KAAA,KAAA,GACA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,QAAA,EAAA,EACA,EAAA,SAAA,KAAA,EAAA,aACA,EAAA,SAAA,KAAA,GAAA,MAAA,EAAA,SACA,EAAA,KAAA,EAAA,GAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EACA,EAAA,KAAA,EAAA,GAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAGA,OADA,EAAA,KAAA,IACA,GA0IA,EAAA,kBAAA,EA6BA,EAAA,kBAhBA,SAAA,EAAA,EAAA,GAEA,IAAA,EAAA,EAAA,EAAA,EAAA,GACA,GAAA,GAAA,EAAA,CAEA,IAAA,EAAA,EAAA,EACA,EAAA,EAAA,KACA,EAAA,SAAA,UACA,EAAA,SAAA,UACA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EACA,EAAA,KAAA,EAAA,KACA,EAAA,KAAA,EAEA,OAAA,GAuCA,EAAA,mBAAA,EAEA;;ACjhCA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAfA,IAAA,EAAA,QAAA,OAOM,EAAqB,CACzB,CAAC,GAAI,UAAW,GAAI,UAAW,GAAI,WACnC,CAAC,GAAI,UAAW,GAAI,UAAW,GAAI,WACnC,CAAC,GAAI,UAAW,GAAI,UAAW,GAAI,YAKrC,EAAA,WASE,SAAA,EAAY,EAAW,EAAW,EAAe,EAAgB,GAC/D,KAAK,EAAI,EACT,KAAK,EAAI,EACT,KAAK,MAAQ,EACb,KAAK,OAAS,EACd,KAAK,YAAc,EACnB,KAAK,IAAM,IAAI,EAAA,IAAI,IAAI,EAAA,OAAO,EAAG,GAAI,EAAO,GAC5C,KAAK,SAAW,EAAO,KAAK,MAAM,KAAK,SAAW,EAAO,SAiD7D,OA9CE,EAAA,UAAA,KAAA,SAAK,GACH,OAAQ,KAAK,aACX,KAAK,EACL,KAAK,EACH,EAAQ,UAAY,KAAK,SAAS,GAClC,EAAQ,SAAS,KAAK,EAAG,KAAK,EAAG,KAAK,MAAO,KAAK,OAAS,GAC3D,EAAQ,UAAY,KAAK,SAAS,GAClC,EAAQ,SAAS,KAAK,EAAG,KAAK,EAAI,KAAK,OAAS,EAAG,KAAK,MAAO,KAAK,OAAS,GAC7E,EAAQ,UAAY,KAAK,SAAS,GAClC,EAAQ,YACR,EAAQ,OAAO,KAAK,EAAG,KAAK,GAC5B,EAAQ,OAAO,KAAK,EAAG,KAAK,EAAI,KAAK,QACrC,EAAQ,OAAO,KAAK,EAAI,KAAK,MAAQ,EAAG,KAAK,EAAI,KAAK,OAAS,GAC/D,EAAQ,OAAO,KAAK,EAAG,KAAK,GAC5B,EAAQ,OAAO,KAAK,EAAI,KAAK,MAAO,KAAK,GACzC,EAAQ,OAAO,KAAK,EAAI,KAAK,MAAQ,KAAK,MAAQ,EAAG,KAAK,EAAI,KAAK,OAAS,GAC5E,EAAQ,OAAO,KAAK,EAAI,KAAK,MAAO,KAAK,EAAI,KAAK,QAClD,EAAQ,OAAO,KAAK,EAAI,KAAK,MAAO,KAAK,GACzC,EAAQ,OACR,MACF,KAAK,EACL,KAAK,EACH,EAAQ,UAAY,KAAK,SAAS,GAClC,EAAQ,SAAS,KAAK,EAAG,KAAK,EAAG,KAAK,MAAQ,EAAG,KAAK,QACtD,EAAQ,UAAY,KAAK,SAAS,GAClC,EAAQ,SAAS,KAAK,EAAI,KAAK,MAAQ,EAAG,KAAK,EAAG,KAAK,MAAQ,EAAG,KAAK,QACvE,EAAQ,UAAY,KAAK,SAAS,GAClC,EAAQ,YACR,EAAQ,OAAO,KAAK,EAAG,KAAK,GAC5B,EAAQ,OAAO,KAAK,EAAI,KAAK,MAAO,KAAK,GACzC,EAAQ,OAAO,KAAK,EAAI,KAAK,MAAQ,EAAG,KAAK,EAAI,KAAK,OAAS,GAC/D,EAAQ,OAAO,KAAK,EAAG,KAAK,GAC5B,EAAQ,OAAO,KAAK,EAAG,KAAK,EAAI,KAAK,QACrC,EAAQ,OAAO,KAAK,EAAI,KAAK,MAAQ,EAAG,KAAK,EAAI,KAAK,OAAS,KAAK,OAAS,GAC7E,EAAQ,OAAO,KAAK,EAAI,KAAK,MAAO,KAAK,EAAI,KAAK,QAClD,EAAQ,OAAO,KAAK,EAAG,KAAK,EAAI,KAAK,QACrC,EAAQ,SAKd,EAAA,UAAA,OAAA,SAAQ,KAER,EAAA,UAAA,OAAA,WACE,OAAO,KAAK,KAEhB,EAjEA,GAAA,QAAA,QAAA;;ACXA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAJA,IAAA,EAAA,QAAA,OAIA,EAAA,WAAA,SAAA,IACU,KAAA,WAA6B,GAoCvC,OAjCS,EAAA,UAAA,IAAP,SAAY,GACV,KAAK,WAAW,KAAK,IAGhB,EAAA,UAAA,SAAP,SAAiB,GACf,KAAK,MAAQ,GAGR,EAAA,UAAA,OAAP,SAAe,GACb,IAAgB,IAAA,EAAA,EAAA,EAAA,KAAK,WAAL,EAAA,EAAA,OAAA,IAAiB,CAArB,EAAA,GACR,OAAO,KAIN,EAAA,UAAA,KAAP,SAAY,GACN,KAAK,OACP,KAAK,MAAM,KAAK,GAGlB,IAAgB,IAAA,EAAA,EAAA,EAAA,KAAK,WAAL,EAAA,EAAA,OAAA,IAAiB,CAArB,EAAA,GACR,KAAK,KAIJ,EAAA,UAAA,eAAP,SAAuB,GACrB,IAAgB,IAAA,EAAA,EAAA,EAAA,KAAK,WAAL,EAAA,EAAA,OAAA,IAAiB,CAA5B,IACG,EADI,EAAA,GACI,SACd,GAAI,IAAO,EAAA,EAAA,oBAAmB,EAAS,EAAI,aACzC,OAAO,EAGX,OAAO,GAEX,EArCA,GAAA,QAAA,QAAA;;ACGA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,IAAA,EAAA,WAIE,SAAA,EAAY,GACV,KAAK,OAAS,EACd,KAAK,KAAO,IAAI,OAChB,KAAK,KAAK,OAAO,KAAK,OAAO,GAAG,EAAG,KAAK,OAAO,GAAG,GAClD,IAAoB,IAAA,EAAA,EAAA,EAAA,KAAK,OAAL,EAAA,EAAA,OAAA,IAAa,CAA5B,IAAM,EAAK,EAAA,GACd,KAAK,KAAK,OAAO,EAAM,EAAG,EAAM,IAwBtC,OApBE,EAAA,UAAA,OAAA,aAEA,EAAA,UAAA,KAAA,SAAK,GAEH,EAAQ,YAAY,IACpB,EAAQ,UAAY,GACpB,EAAQ,YAAc,UACtB,EAAQ,OAAO,KAAK,MAEpB,EAAQ,UAAY,GACpB,EAAQ,YAAc,UACtB,EAAQ,OAAO,KAAK,MAEpB,EAAQ,YAAY,CAAC,EAAG,KACxB,EAAQ,UAAY,EACpB,EAAQ,YAAc,UACtB,EAAQ,OAAO,KAAK,OAGtB,EAAA,UAAA,OAAA,SAAQ,KACV,EAjCA,GAAA,QAAA,QAAA;;ACLA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,IAAA,EAAA,WAOE,SAAA,EAAY,EAAW,EAAW,EAAe,EAAgB,QAAA,IAAA,IAAA,EAAA,GAC/D,KAAK,EAAI,EACT,KAAK,EAAI,EACT,KAAK,MAAQ,EACb,KAAK,OAAS,EACd,KAAK,YAAc,EA4DvB,OAzDE,EAAA,UAAA,OAAA,aAEA,EAAA,UAAA,KAAA,SAAK,GACH,EAAQ,YAAc,UACtB,EAAQ,YAAY,IACpB,EAAQ,UAAY,EACpB,EAAQ,WAAW,KAAK,EAAG,KAAK,EAAG,KAAK,MAAO,KAAK,QACpD,EAAQ,YAAY,CAAC,EAAG,IACxB,EAAQ,UAAY,EACpB,EAAQ,WAAW,KAAK,EAAG,KAAK,EAAG,KAAK,MAAO,KAAK,QACpD,EAAQ,YAAY,IACpB,EAAQ,UAAY,UACpB,EAAQ,UAAY,EACpB,EAAQ,SAAS,KAAK,EAAI,EAAG,KAAK,EAAI,EAAG,EAAG,GAC5C,EAAQ,SAAS,KAAK,EAAI,EAAI,KAAK,MAAO,KAAK,EAAI,EAAG,EAAG,GACzD,EAAQ,SAAS,KAAK,EAAI,EAAG,KAAK,EAAI,EAAI,KAAK,OAAQ,EAAG,GAC1D,EAAQ,SAAS,KAAK,EAAI,EAAI,KAAK,MAAO,KAAK,EAAI,EAAI,KAAK,OAAQ,EAAG,GAIvE,OADA,EAAQ,UAAY,UACZ,KAAK,aACX,KAAK,EACH,EAAQ,SACN,KAAK,EAAI,KAAK,MAAQ,EAAI,GAC1B,KAAK,EAAI,EANQ,GAQjB,GAEF,MACF,KAAK,EACH,EAAQ,SACN,KAAK,EAAI,KAAK,MAAQ,EACtB,KAAK,EAAI,KAAK,OAAS,EAAI,GAC3B,EAfiB,IAkBnB,MACF,KAAK,EACH,EAAQ,SACN,KAAK,EAAI,KAAK,MAAQ,EAAI,GAC1B,KAAK,EAAI,KAAK,OAAS,EAtBN,GAwBjB,GAEF,MACF,KAAK,EACH,EAAQ,SACN,KAAK,EAAI,EACT,KAAK,EAAI,KAAK,OAAS,EAAI,GAC3B,EA/BiB,MAsCzB,EAAA,UAAA,OAAA,SAAQ,KACV,EAxEA,GAAA,QAAA,QAAA;;ACGA,aAAA,IAAA,EAAA,MAAA,KAAA,iBAAA,SAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,IAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IALA,IAAA,EAAA,QAAA,OAEA,EAAA,EAAA,QAAA,YACA,EAAA,EAAA,QAAA,WAEA,EAAA,WAQE,SAAA,EAAY,EAAW,EAAW,EAAe,GAHzC,KAAA,WAA6B,GAInC,KAAK,EAAI,EACT,KAAK,EAAI,EACT,KAAK,MAAQ,EACb,KAAK,OAAS,EACd,KAAK,IAAM,IAAI,EAAA,IAAI,IAAI,EAAA,OAAO,EAAG,GAAI,EAAO,GA0BhD,OAvBE,EAAA,UAAA,KAAA,SAAK,GACH,EAAQ,UAAY,UACpB,EAAQ,SAAS,KAAK,EAAG,KAAK,EAAG,KAAK,MAAO,KAAK,QAClD,IAAgB,IAAA,EAAA,EAAA,EAAA,KAAK,WAAL,EAAA,EAAA,OAAA,IAAiB,CAArB,EAAA,GACR,KAAK,KAIX,EAAA,UAAA,OAAA,SAAQ,KAER,EAAA,UAAA,QAAA,SAAS,GAAC,IAAA,EAAW,EAAA,YACb,EAAO,IAAI,EAAA,QAAK,KAAK,EAAG,KAAK,EAAG,KAAK,MAAO,KAAK,OAAQ,GAC/D,KAAK,WAAW,KAAK,IAGvB,EAAA,UAAA,SAAA,SAAU,GAAC,IAAA,EAAC,EAAA,EAAE,EAAC,EAAA,EAAE,EAAK,EAAA,MAAE,EAAM,EAAA,OAAE,EAAW,EAAA,YACnC,EAAQ,IAAI,EAAA,QAAM,KAAK,EAAI,EAAG,KAAK,EAAI,EAAG,EAAO,EAAQ,GAC/D,KAAK,WAAW,KAAK,IAGvB,EAAA,UAAA,OAAA,WACE,OAAO,KAAK,KAEhB,EAvCA,GAAA,QAAA,QAAA;;ACiCa,aAAA,IApCD,EAoCC,EAAA,MAAA,KAAA,WAAA,WAAA,IAAA,EAAA,SAAA,EAAA,GAAA,OAAA,EAAA,OAAA,gBAAA,CAAA,UAAA,cAAA,OAAA,SAAA,EAAA,GAAA,EAAA,UAAA,IAAA,SAAA,EAAA,GAAA,IAAA,IAAA,KAAA,EAAA,OAAA,UAAA,eAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,MAAA,EAAA,IAAA,OAAA,SAAA,EAAA,GAAA,GAAA,mBAAA,GAAA,OAAA,EAAA,MAAA,IAAA,UAAA,uBAAA,OAAA,GAAA,iCAAA,SAAA,IAAA,KAAA,YAAA,EAAA,EAAA,EAAA,GAAA,EAAA,UAAA,OAAA,EAAA,OAAA,OAAA,IAAA,EAAA,UAAA,EAAA,UAAA,IAAA,IAAA,GAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,oBAAA,QAAA,mBAAA,QAAA,iBAAA,QAAA,mBAAA,QAAA,yBAAA,EApCb,SAAY,GACV,EAAA,EAAA,IAAA,GAAA,MAAK,EAAA,EAAA,OAAA,GAAA,SAAQ,EAAA,EAAA,MAAA,GAAA,QADf,CAAY,EAAA,QAAA,sBAAA,QAAA,oBAAmB,KAI/B,IAAA,EAAA,WAQA,OANE,SAAa,GACX,KAAK,GAAK,GAHd,GAAsB,QAAA,mBAAA,EAUtB,IAAA,EAAA,SAAA,GAAA,SAAA,IAsBa,OAAA,OAAA,GAAA,EAAA,MAAA,KAAA,YAAA,KAbb,OATsC,EAAA,EAAA,GACpC,EAAA,UAAA,MAAA,WACE,KAAK,GAAG,QAAU,IAClB,KAAK,GAAG,KAAO,GAGjB,EAAA,UAAA,KAAA,WACE,KAAK,GAAG,SAAS,EAAoB,QAEzC,EATA,CAAsC,GAAzB,QAAA,iBAAA,EAWb,IAAA,EAAA,SAAA,GAAA,SAAA,IAWa,OAAA,OAAA,GAAA,EAAA,MAAA,KAAA,YAAA,KAFb,OATwC,EAAA,EAAA,GACtC,EAAA,UAAA,MAAA,WACE,KAAK,GAAG,QAAU,IAClB,KAAK,GAAG,KAAO,GAGjB,EAAA,UAAA,KAAA,WACE,KAAK,GAAG,SAAS,EAAoB,SAEzC,EATA,CAAwC,GAA3B,QAAA,mBAAA,EAWb,IAAA,EAAA,SAAA,GAAA,SAAA,IAAa,OAAA,OAAA,GAAA,EAAA,MAAA,KAAA,YAAA,KASb,OATyC,EAAA,EAAA,GACvC,EAAA,UAAA,MAAA,WACE,KAAK,GAAG,QAAU,IAClB,KAAK,GAAG,KAAO,GAGjB,EAAA,UAAA,KAAA,WACE,KAAK,GAAG,SAAS,EAAoB,MAEzC,EATA,CAAyC,GAA5B,QAAA,oBAAA;;AC5Bb,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAVA,IAAA,EAAA,QAAA,OAEA,EAAA,QAAA,wBAQA,EAAA,WAaE,SAAA,EAAa,EAAW,EAAW,GAbrC,IAAA,EAcI,KAAK,EAAI,EACT,KAAK,EAAI,EACT,KAAK,IAAM,EACA,GAAP,GACF,KAAK,MAAQ,GACb,KAAK,OAAS,KAEd,KAAK,MAAQ,GACb,KAAK,OAAS,IAEhB,KAAK,IAAM,IAAI,EAAA,IAAI,IAAI,EAAA,OAAO,KAAK,EAAG,KAAK,GAAI,KAAK,MAAO,KAAK,QAEhE,KAAK,KAAO,EACZ,KAAK,QAAU,EACf,KAAK,SAAM,EAAA,IACR,EAAA,oBAAoB,OAAQ,IAAI,EAAA,mBAAmB,MACpD,EAAC,EAAA,oBAAoB,KAAM,IAAI,EAAA,iBAAiB,MAChD,EAAC,EAAA,oBAAoB,QAAS,IAAI,EAAA,oBAAoB,MACvD,GACD,KAAK,aAAe,KAAK,OAAO,EAAA,oBAAoB,OACpD,KAAK,SAAS,EAAA,oBAAoB,OAsDtC,OAnDE,EAAA,UAAA,KAAA,SAAM,GAGJ,GAFA,EAAQ,UAAY,UACpB,EAAQ,SAAS,KAAK,EAAG,KAAK,EAAG,KAAK,MAAO,KAAK,QAClC,GAAZ,KAAK,IAAU,CACjB,IAAM,EAAS,KAAK,OAAS,EAAI,EAC3B,EAAU,KAAK,OAAS,EAC9B,EAAQ,YACR,EAAQ,UAAY,WAAa,KAAK,wBAAyB,EAAA,iBAAmB,GAAK,MACvF,EAAQ,IAAI,KAAK,EAAI,KAAK,MAAQ,EAAG,KAAK,GAAe,EAAV,EAAc,GAAS,EAAG,EAAG,EAAI,KAAK,IACrF,EAAQ,OACR,EAAQ,YACR,EAAQ,UAAY,WAAa,KAAK,wBAAyB,EAAA,oBAAsB,GAAK,MAC1F,EAAQ,IAAI,KAAK,EAAI,KAAK,MAAQ,EAAG,KAAK,GAAe,EAAV,EAAc,GAAS,EAAG,EAAG,EAAI,KAAK,IACrF,EAAQ,OACR,EAAQ,YACR,EAAQ,UAAY,WAAa,KAAK,wBAAyB,EAAA,mBAAqB,GAAK,MACzF,EAAQ,IAAI,KAAK,EAAI,KAAK,MAAQ,EAAG,KAAK,GAAe,EAAV,EAAc,GAAS,EAAG,EAAG,EAAI,KAAK,IACrF,EAAQ,WACH,CACC,EAAS,KAAK,MAAQ,EAAI,EAC1B,EAAU,KAAK,MAAQ,EAC7B,EAAQ,YACR,EAAQ,UAAY,WAAa,KAAK,wBAAyB,EAAA,iBAAmB,GAAK,MACvF,EAAQ,IAAI,KAAK,GAAe,EAAV,EAAc,GAAS,KAAK,EAAI,KAAK,OAAS,EAAG,EAAG,EAAG,EAAI,KAAK,IACtF,EAAQ,OACR,EAAQ,YACR,EAAQ,UAAY,WAAa,KAAK,wBAAyB,EAAA,oBAAsB,GAAK,MAC1F,EAAQ,IAAI,KAAK,GAAe,EAAV,EAAc,GAAS,KAAK,EAAI,KAAK,OAAS,EAAG,EAAG,EAAG,EAAI,KAAK,IACtF,EAAQ,OACR,EAAQ,YACR,EAAQ,UAAY,WAAa,KAAK,wBAAyB,EAAA,mBAAqB,GAAK,MACzF,EAAQ,IAAI,KAAK,GAAe,EAAV,EAAc,GAAS,KAAK,EAAI,KAAK,OAAS,EAAG,EAAG,EAAG,EAAI,KAAK,IACtF,EAAQ,SAIZ,EAAA,UAAA,OAAA,SAAQ,GACN,KAAK,MAAQ,EACT,KAAK,MAAQ,KAAK,SACpB,KAAK,aAAa,QAItB,EAAA,UAAA,OAAA,WACE,OAAO,KAAK,wBAAwB,EAAA,iBAAmB,KAAK,SAAM,GAGpE,EAAA,UAAA,SAAA,SAAU,GACR,KAAK,aAAe,KAAK,OAAO,GAChC,KAAK,aAAa,SAEtB,EAxFA,GAAA,QAAA,QAAA;;ACAA,aAAA,IAAA,EAAA,MAAA,KAAA,iBAAA,SAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,IAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAVA,IAAA,EAAA,EAAA,QAAA,gBACA,EAAA,EAAA,QAAA,gBACA,EAAA,EAAA,QAAA,cACA,EAAA,EAAA,QAAA,eACA,EAAA,EAAA,QAAA,kBACA,EAAA,EAAA,QAAA,wBAKA,EAAA,WAGE,SAAA,IACE,KAAK,IAAM,IAAI,EAAA,QA8CnB,OA3CS,EAAA,UAAA,UAAP,WAAkB,IAAA,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,UAAA,OAAA,IAAA,EAAA,GAAA,UAAA,GAChB,IAAM,EAAO,IAAI,EAAA,QAAK,GAEtB,OADA,KAAK,IAAI,IAAI,GACN,MAGF,EAAA,UAAA,WAAP,SAAmB,EAAW,EAAW,EAAe,EAAgB,GACtE,IAAM,EAAQ,IAAI,EAAA,QAAM,EAAG,EAAG,EAAO,EAAQ,GAE7C,OADA,KAAK,IAAI,SAAS,GACX,MAGF,EAAA,UAAA,mBAAP,SAA2B,EAAW,EAAW,GAC/C,IAAM,EAAK,IAAI,EAAA,QAAc,EAAG,EAAG,GAEnC,OADA,KAAK,IAAI,IAAI,GACN,MAGF,EAAA,UAAA,aAAP,SAAqB,EAAW,EAAW,EAAe,EAAgB,QAAA,IAAA,IAAA,EAAA,IACxE,IAAM,EAAU,IAAI,EAAA,QAAQ,EAAG,EAAG,EAAO,GAYzC,OAXA,EAAQ,QAAQ,SAAC,GAAC,IAAA,EAAI,EAAA,KAAE,EAAK,EAAA,MAC3B,OAAQ,GACN,IAAK,OACH,EAAQ,QAAQ,GAChB,MACF,IAAK,QACH,EAAQ,SAAS,MAIvB,KAAK,IAAI,IAAI,GACN,MAGF,EAAA,UAAA,WAAP,SAAmB,EAAW,EAAW,EAAe,EAAgB,GACtE,IAAM,EAAQ,IAAI,EAAA,QAAM,EAAG,EAAG,EAAO,EAAQ,GAE7C,OADA,KAAK,IAAI,IAAI,GACN,MAGF,EAAA,UAAA,MAAP,WACE,OAAO,KAAK,KAEhB,EAlDA,GAAA,QAAA,QAAA;;ACVA,aAAA,SAAgB,EAAY,EAAW,EAAW,GAChD,IAAM,EAAU,EAAS,KAAK,GAAM,IAGpC,MAAO,CAAE,EAFI,EAAI,KAAK,IAAI,GAAU,EAAI,KAAK,IAAI,GAE/B,EADL,EAAI,KAAK,IAAI,GAAU,EAAI,KAAK,IAAI,IAHnD,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,iBAAA,EAAA,QAAA,YAAA;;ACAA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,IAAA,EAAA,WAQE,SAAA,EAAa,EAAW,GACtB,KAAK,mBAAoB,EACzB,KAAK,EAAI,EACT,KAAK,EAAI,EACT,KAAK,KAAO,KAAK,SAAW,EAC5B,KAAK,OAAS,KAAK,SACnB,KAAK,OAAS,KAAK,SAWvB,OARE,EAAA,UAAA,OAAA,WACE,KAAK,GAAK,KAAK,OACf,KAAK,GAAK,KAAK,OACf,KAAK,MAAQ,MACT,KAAK,KAAO,IAAG,KAAK,mBAAoB,IAIhD,EAzBA,GAAA,QAAA,QAAA;;ACE2C,aAAA,IAAA,EAAA,MAAA,KAAA,WAAA,WAAA,IAAA,EAAA,SAAA,EAAA,GAAA,OAAA,EAAA,OAAA,gBAAA,CAAA,UAAA,cAAA,OAAA,SAAA,EAAA,GAAA,EAAA,UAAA,IAAA,SAAA,EAAA,GAAA,IAAA,IAAA,KAAA,EAAA,OAAA,UAAA,eAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,MAAA,EAAA,IAAA,OAAA,SAAA,EAAA,GAAA,GAAA,mBAAA,GAAA,OAAA,EAAA,MAAA,IAAA,UAAA,uBAAA,OAAA,GAAA,iCAAA,SAAA,IAAA,KAAA,YAAA,EAAA,EAAA,EAAA,GAAA,EAAA,UAAA,OAAA,EAAA,OAAA,OAAA,IAAA,EAAA,UAAA,EAAA,UAAA,IAAA,IAAA,GAAA,EAAA,MAAA,KAAA,iBAAA,SAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,IAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAF3C,IAAA,EAAA,EAAA,QAAA,eAEA,EAAA,SAAA,GAAA,SAAA,IAAA,IAAA,EAAA,OAAA,GAAA,EAAA,MAAA,KAAA,YAAA,KAA2C,OACjC,EAAA,MAAgB,YADiB,EAS3C,OATmC,EAAA,EAAA,GAGjC,EAAA,UAAA,KAAA,SAAM,GACJ,EAAQ,YACR,EAAQ,IAAI,KAAK,EAAG,KAAK,EAAG,KAAK,KAAM,EAAa,EAAV,KAAK,IAC/C,EAAQ,UAAY,KAAK,MACzB,EAAQ,QAEZ,EATA,CAAmC,EAAA,SAAQ,QAAA,QAAA;;AC8C9B,aAAA,IAAA,EAAA,MAAA,KAAA,WAAA,WAAA,IAAA,EAAA,SAAA,EAAA,GAAA,OAAA,EAAA,OAAA,gBAAA,CAAA,UAAA,cAAA,OAAA,SAAA,EAAA,GAAA,EAAA,UAAA,IAAA,SAAA,EAAA,GAAA,IAAA,IAAA,KAAA,EAAA,OAAA,UAAA,eAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,MAAA,EAAA,IAAA,OAAA,SAAA,EAAA,GAAA,GAAA,mBAAA,GAAA,OAAA,EAAA,MAAA,IAAA,UAAA,uBAAA,OAAA,GAAA,iCAAA,SAAA,IAAA,KAAA,YAAA,EAAA,EAAA,EAAA,GAAA,EAAA,UAAA,OAAA,EAAA,OAAA,OAAA,IAAA,EAAA,UAAA,EAAA,UAAA,IAAA,IAAA,GAAA,EAAA,MAAA,KAAA,iBAAA,SAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,IAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,YAAA,QAAA,WAAA,QAAA,SAAA,QAAA,eAAA,EAhDb,IAGY,EAHZ,EAAA,EAAA,QAAA,uBAGA,SAAY,GAAY,EAAA,EAAA,GAAA,GAAA,KAAI,EAAA,EAAA,IAAA,GAAA,MAA5B,CAAY,EAAA,QAAA,YAAA,QAAA,UAAS,KAErB,IAAA,EAAA,WAOA,OALE,SAAa,GACX,KAAK,IAAM,GAHf,GAAsB,QAAA,SAAA,EAStB,IAAA,EAAA,SAAA,GAAA,SAAA,IAkCa,OAAA,OAAA,GAAA,EAAA,MAAA,KAAA,YAAA,KAFb,OAhCgC,EAAA,EAAA,GAC9B,EAAA,UAAA,OAAA,SAAO,EAAiB,GACtB,KAAK,IAAI,KAAK,YACZ,IAAI,EAAA,QACF,KAAK,IAAI,EAAI,KAAK,KAAK,KAAK,IAAI,OAAS,KAAO,KAAK,GAAK,OAA0B,GAAjB,KAAK,IAAI,OAC5E,KAAK,IAAI,EAAI,KAAK,KAAK,KAAK,IAAI,OAAS,KAAO,KAAK,GAAK,OAA0B,GAAjB,KAAK,IAAI,SAI5E,EAAM,SAAS,cACjB,KAAK,IAAI,SAAS,EAAU,KAE1B,EAAM,SAAS,WACb,KAAK,IAAI,MAAQ,KAAK,IAAI,WAC5B,KAAK,IAAI,OAAS,KAAK,IAAI,cAEpB,EAAM,SAAS,cACpB,KAAK,IAAI,MAAQ,KAAK,IAAI,kBAC5B,KAAK,IAAI,OAAS,KAAK,IAAI,cAIT,GAAlB,KAAK,IAAI,QACP,EAAM,SAAS,gBACjB,KAAK,IAAI,QAAU,KAAK,IAAI,YAAc,KAAK,IAAI,OAGjD,EAAM,SAAS,eACjB,KAAK,IAAI,QAAU,KAAK,IAAI,YAAc,KAAK,IAAI,SAI3D,EAhCA,CAAgC,GAAnB,QAAA,WAAA,EAkCb,IAAA,EAAA,SAAA,GAAA,SAAA,IAAa,OAAA,OAAA,GAAA,EAAA,MAAA,KAAA,YAAA,KAMb,OANiC,EAAA,EAAA,GAC/B,EAAA,UAAA,OAAA,SAAO,EAAiB,GAClB,EAAM,SAAS,UACjB,KAAK,IAAI,SAAS,EAAU,KAGlC,EANA,CAAiC,GAApB,QAAA,YAAA;;AC3Cb,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IALA,IAAA,EAAA,QAAA,OAEA,EAAA,QAAA,YACA,EAAA,QAAA,eAEA,EAAA,WAkBE,SAAA,EAAa,EAAY,GAlB3B,IAAA,EAkB4B,EAAC,EAAA,EAAE,EAAC,EAAA,EAAE,EAAM,EAAA,OACpC,KAAK,KAAO,EACZ,KAAK,EAAI,EACT,KAAK,EAAI,EACT,KAAK,OAAS,EAEd,KAAK,MAAQ,SAAS,cAAc,QACpC,KAAK,MAAQ,KAAK,MAAM,MACxB,KAAK,OAAS,KAAK,MAAM,OAEzB,KAAK,MAAQ,EACb,KAAK,SAAW,EAChB,KAAK,iBAAmB,EACxB,KAAK,aAAe,IACpB,KAAK,WAAa,IAClB,KAAK,YAAc,IAEnB,KAAK,SAAM,EAAA,IACR,EAAA,UAAU,IAAK,IAAI,EAAA,WAAW,MAC/B,EAAC,EAAA,UAAU,KAAM,IAAI,EAAA,YAAY,MAClC,GACD,KAAK,aAAe,KAAK,OAAO,EAAA,UAAU,KAiF9C,OA9ES,EAAA,UAAA,OAAP,SAAe,EAAiB,GAC9B,KAAK,aAAa,OAAO,EAAO,GAE5B,KAAK,MAAQ,GACf,KAAK,OAAS,KAAK,WACnB,KAAK,MAAQ,KAAK,IAAI,EAAG,KAAK,QACrB,KAAK,MAAQ,IACtB,KAAK,OAAS,KAAK,WACnB,KAAK,MAAQ,KAAK,IAAI,EAAG,KAAK,QAGhC,IAAM,GAAU,KAAK,OAAS,KAAO,KAAK,GAAK,KACzC,EAAK,KAAK,IAAI,GAAU,KAAK,MAC7B,EAAK,KAAK,IAAI,GAAU,KAAK,MAGnC,KAAK,GAAK,EACV,KAAK,GAAK,GAGL,EAAA,UAAA,KAAP,SAAa,GACX,EAAQ,OACR,EAAQ,UAAU,KAAK,EAAG,KAAK,GAC/B,EAAQ,OAAQ,KAAK,GAAK,IAAO,KAAK,QAEtC,EAAQ,UACN,KAAK,MACL,EACA,EACA,KAAK,MACL,KAAK,OACS,IAAb,KAAK,MACS,IAAd,KAAK,OACO,GAAb,KAAK,MACS,GAAd,KAAK,QAEP,EAAQ,WAGV,OAAA,eAAI,EAAA,UAAA,SAAM,CAAV,IAAA,WACE,OAAQ,KAAK,OAAS,KAAO,KAAK,GAAK,MAlF3C,YAAA,EAAA,cAAA,IAqFS,EAAA,UAAA,SAAP,SAAiB,GACf,KAAK,aAAe,KAAK,OAAO,IAGlC,OAAA,eAAI,EAAA,UAAA,UAAO,CAAX,IAAA,WACE,IAAM,GAAU,EAAA,EAAA,aACA,IAAb,KAAK,MACS,IAAd,KAAK,OACN,KAAK,QAED,GAAW,EAAA,EAAA,aACF,GAAb,KAAK,MACU,IAAd,KAAK,OACN,KAAK,QAED,GAAc,EAAA,EAAA,aACL,GAAb,KAAK,MACS,GAAd,KAAK,OACL,KAAK,QAED,GAAa,EAAA,EAAA,aACH,IAAb,KAAK,MACQ,GAAd,KAAK,OACL,KAAK,QAGD,EAAS,CACb,IAAI,EAAA,OAAO,KAAK,EAAI,EAAQ,EAAG,KAAK,EAAI,EAAQ,GAChD,IAAI,EAAA,OAAO,KAAK,EAAI,EAAS,EAAG,KAAK,EAAI,EAAS,GAClD,IAAI,EAAA,OAAO,KAAK,EAAI,EAAY,EAAG,KAAK,EAAI,EAAY,GACxD,IAAI,EAAA,OAAO,KAAK,EAAI,EAAW,EAAG,KAAK,EAAI,EAAW,IAGxD,OAAO,IAAI,EAAA,QAAQ,IAAI,EAAA,OAAU,IAtHrC,YAAA,EAAA,cAAA,IAwHA,EAxHA,GAAA,QAAA,QAAA;;ACDA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAJA,IAAA,EAAA,QAAA,OAEA,EAAA,QAAA,mBAEA,EAAA,WAQE,SAAA,EAAY,EAAW,GACrB,KAAK,EAAI,EACT,KAAK,EAAI,EACT,KAAK,MAAQ,SAAS,cAAc,YACpC,KAAK,MAAQ,KAAK,MAAM,MACxB,KAAK,OAAS,KAAK,MAAM,OACzB,KAAK,IAAM,IAAI,EAAA,IAAI,IAAI,EAAA,OAAO,EAAG,GAAI,KAAK,MAAO,KAAK,QAiB1D,OAdE,EAAA,UAAA,KAAA,SAAM,GACJ,EAAQ,UACN,KAAK,MACL,KAAK,EACL,KAAK,EACL,KAAK,MACL,KAAK,SAIT,EAAA,UAAA,SAAA,SAAU,GACR,OAAO,EAAI,wBAAwB,EAAA,cAC9B,EAAA,EAAA,oBAAmB,EAAI,QAAS,KAAK,IAAI,cAElD,EA/BA,GAAA,QAAA,QAAA;;ACsDE,aAAA,IAAA,EAAA,MAAA,KAAA,iBAAA,SAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,IAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IA1DF,QAAA,gBAEA,IAAA,EAAA,EAAA,QAAA,mBACA,EAAA,EAAA,QAAA,yBACA,EAAA,EAAA,QAAA,sBACA,EAAA,EAAA,QAAA,mBAEA,OAAO,iBAAiB,OAAQ,WAC9B,IAAM,EAAS,SAAS,cAAc,UACtC,GAAK,EAAL,CACA,IAAM,EAAU,EAAO,WAAW,MAClC,GAAK,EAAL,CACA,EAAO,MAAQ,IACf,EAAO,OAAS,IAEhB,IAAM,EAAO,IAAI,EAAA,QAAK,EAAO,MAAO,EAAO,QAErC,GAAM,IAAI,EAAA,SACb,UAAU,CAAC,EAAG,EAAG,EAAG,IAAK,CAAC,EAAG,EAAO,MAAO,EAAG,KAC9C,UAAU,CAAC,EAAG,IAAK,EAAG,IAAK,CAAC,EAAG,IAAK,EAAG,EAAO,SAC9C,UAAU,CAAC,EAAG,IAAK,EAAG,KAAM,CAAC,EAAG,EAAO,MAAO,EAAG,MACjD,UAAU,CAAC,EAAG,IAAK,EAAG,KAAM,CAAC,EAAG,IAAK,EAAG,MACxC,WAAW,IAAK,IAAK,IAAK,IAAK,GAC/B,aAAa,IAAK,IAAK,IAAK,IAAK,CAChC,CAAC,KAAM,OAAQ,MAAO,CAAC,YAAa,IACpC,CAAC,KAAM,QAAS,MAAO,CAAC,EAAG,IAAK,EAAG,GAAI,MAAO,IAAK,OAAQ,IAAK,YAAa,MAE9E,aAAa,GAAI,IAAK,IAAK,IAAK,CAC/B,CAAC,KAAM,QAAS,MAAO,CAAC,EAAG,GAAI,EAAG,IAAK,MAAO,IAAK,OAAQ,IAAK,YAAa,IAC7E,CAAC,KAAM,QAAS,MAAO,CAAC,EAAG,GAAI,EAAG,GAAI,MAAO,IAAK,OAAQ,GAAI,YAAa,MAE5E,aAAa,GAAI,IAAK,IAAK,IAAK,CAC/B,CAAC,KAAM,QAAS,MAAO,CAAC,EAAG,GAAI,EAAG,GAAI,MAAO,IAAK,OAAQ,IAAK,YAAa,MAE7E,aAAa,IAAK,IAAK,IAAK,IAAK,CAChC,CAAC,KAAM,OAAQ,MAAO,CAAC,YAAa,MAErC,WAAW,EAAG,EAAG,EAAO,MAAO,EAAO,OAAQ,WAC9C,mBAAmB,IAAK,GAAI,GAC5B,mBAAmB,IAAK,IAAK,GAC7B,QACG,EAAM,IAAI,EAAA,QAAI,EAAM,CAAC,EAAG,GAAI,EAAG,GAAI,OAAQ,KAC3C,EAAO,IAAI,EAAA,QAAK,IAAK,KAE3B,EAAK,OAAO,GACZ,EAAK,OAAO,GACZ,EAAK,QAAQ,GAEb,IAAI,EAAW,GACC,SAAV,EAAW,GACf,IAAM,EAAY,EAAY,EAC9B,EAAW,EACX,EAAQ,UAAU,EAAG,EAAG,EAAO,MAAO,EAAO,QAC7C,EAAK,OAAO,GACZ,EAAK,KAAK,GACL,EAAK,KAAQ,EAAK,UAAU,OAAO,sBAAsB,GAEhE,CAAQ","file":"src.2b93198d.js","sourceRoot":"..","sourcesContent":["import Game from \"./game\";\r\n\r\nexport default class InputHandler {\r\n  private keys: string[];\r\n\r\n  constructor () {\r\n    this.keys = [];\r\n\r\n    const keys = [\"ArrowDown\", \"ArrowUp\", \"ArrowLeft\", \"ArrowRight\", \"Enter\", \"Backspace\"];\r\n    window.addEventListener(\"keydown\", (e) => {\r\n      if (keys.includes(e.key) && !this.keys.includes(e.key)) {\r\n        this.keys.push(e.key);\r\n      }\r\n    });\r\n    window.addEventListener(\"keyup\", (e) => {\r\n      if (this.keys.includes(e.key)) {\r\n        this.keys.splice(this.keys.indexOf(e.key), 1);\r\n      }\r\n    });\r\n  }\r\n\r\n  public getKeys ():string[] {\r\n    return this.keys\r\n  }\r\n}","import Car from \"./car/car\";\r\nimport Goal from \"./goal\";\r\nimport InputHandler from \"./inputHandler\";\r\nimport Map from \"./map/map\";\r\nimport Particle from \"./particle/particle\";\r\n\r\nexport default class Game {\r\n  private width: number;\r\n  private height: number;\r\n  private map: Map|null;\r\n  private car: Car|null;\r\n  private goal: Goal|null;\r\n  private particles: Particle[] = [];\r\n  private inputHandler: InputHandler;\r\n  public win: boolean = false;\r\n  public gameOver: boolean = false;\r\n\r\n  constructor(width: number, height: number) {\r\n    this.width = width;\r\n    this.height = height;\r\n    this.map = null;\r\n    this.car = null;\r\n    this.goal = null;\r\n    this.inputHandler = new InputHandler();\r\n  }\r\n\r\n  public setMap(map: Map): void {\r\n    this.map = map;\r\n  }\r\n\r\n  public setCar(car: Car): void {\r\n    this.car = car;\r\n  }\r\n\r\n  public setGoal(goal: Goal): void {\r\n    this.goal = goal;\r\n  }\r\n\r\n  public addParticle (particle: Particle): void {\r\n    this.particles.push(particle);\r\n  }\r\n\r\n  public update(deltaTime: number): void {\r\n    this.checkCollision();\r\n    this.checkWin()\r\n    //\r\n    if (this.map) {\r\n      this.map.update(deltaTime);\r\n    }\r\n    if (this.car) {\r\n      this.car.update(this.inputHandler.getKeys(), deltaTime);\r\n    }\r\n    this.particles.forEach((particle) => {\r\n      particle.update();\r\n    });\r\n\r\n    this.particles = this.particles.filter(particle => !particle.markedForDeletion);\r\n  }\r\n\r\n  public draw(context: CanvasRenderingContext2D): void {\r\n    if (this.map) {\r\n      this.map.draw(context);\r\n    }\r\n    if (this.goal) {\r\n      this.goal.draw(context);\r\n    }\r\n    if (this.car) {\r\n      this.car.draw(context);\r\n    }\r\n    this.particles.forEach((particle) => {\r\n      particle.draw(context);\r\n    });\r\n  }\r\n\r\n  public checkCollision (): void {\r\n    if (this.car) {\r\n      if (this.map?.checkCollision(this.car.polygon)) {\r\n        this.gameOver = true;\r\n        alert(\"Colis√£o\");\r\n      }\r\n    }\r\n  }\r\n\r\n  public checkWin (): void {\r\n    if (this.car && this.goal && this.goal.checkWin(this.car)) {\r\n      this.win = true;\r\n      alert(\"Fim\");\r\n    }\r\n  }\r\n}","export default class Floor {\r\n  private x: number;\r\n  private y: number;\r\n  private width: number;\r\n  private height: number;\r\n  private color: string;\r\n\r\n  constructor(x: number, y: number, width: number, height: number, color: string) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = width;\r\n    this.height = height;\r\n    this.color = color;\r\n  }\r\n\r\n  public draw(context: CanvasRenderingContext2D): void {\r\n    context.fillStyle = this.color;\r\n    context.fillRect(this.x, this.y, this.width, this.height);\r\n  }\r\n}\r\n","// Version 0.9.0 - Copyright 2012 - 2021 -  Jim Riecken <jimr@jimr.ca>\n//\n// Released under the MIT License - https://github.com/jriecken/sat-js\n//\n// A simple library for determining intersections of circles and\n// polygons using the Separating Axis Theorem.\n/** @preserve SAT.js - Version 0.9.0 - Copyright 2012 - 2021 - Jim Riecken <jimr@jimr.ca> - released under the MIT License. https://github.com/jriecken/sat-js */\n\n/*global define: false, module: false*/\n/*jshint shadow:true, sub:true, forin:true, noarg:true, noempty:true,\n  eqeqeq:true, bitwise:true, strict:true, undef:true,\n  curly:true, browser:true */\n\n// Create a UMD wrapper for SAT. Works in:\n//\n//  - Plain browser via global SAT variable\n//  - AMD loader (like require.js)\n//  - Node.js\n//\n// The quoted properties all over the place are used so that the Closure Compiler\n// does not mangle the exposed API in advanced mode.\n/**\n * @param {*} root - The global scope\n * @param {Function} factory - Factory that creates SAT module\n */\n(function (root, factory) {\n  \"use strict\";\n  if (typeof define === 'function' && define['amd']) {\n    define(factory);\n  } else if (typeof exports === 'object') {\n    module['exports'] = factory();\n  } else {\n    root['SAT'] = factory();\n  }\n}(this, function () {\n  \"use strict\";\n\n  var SAT = {};\n\n  //\n  // ## Vector\n  //\n  // Represents a vector in two dimensions with `x` and `y` properties.\n\n\n  // Create a new Vector, optionally passing in the `x` and `y` coordinates. If\n  // a coordinate is not specified, it will be set to `0`\n  /**\n   * @param {?number=} x The x position.\n   * @param {?number=} y The y position.\n   * @constructor\n   */\n  function Vector(x, y) {\n    this['x'] = x || 0;\n    this['y'] = y || 0;\n  }\n  SAT['Vector'] = Vector;\n  // Alias `Vector` as `V`\n  SAT['V'] = Vector;\n\n\n  // Copy the values of another Vector into this one.\n  /**\n   * @param {Vector} other The other Vector.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['copy'] = Vector.prototype.copy = function (other) {\n    this['x'] = other['x'];\n    this['y'] = other['y'];\n    return this;\n  };\n\n  // Create a new vector with the same coordinates as this on.\n  /**\n   * @return {Vector} The new cloned vector\n   */\n  Vector.prototype['clone'] = Vector.prototype.clone = function () {\n    return new Vector(this['x'], this['y']);\n  };\n\n  // Change this vector to be perpendicular to what it was before. (Effectively\n  // roatates it 90 degrees in a clockwise direction)\n  /**\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['perp'] = Vector.prototype.perp = function () {\n    var x = this['x'];\n    this['x'] = this['y'];\n    this['y'] = -x;\n    return this;\n  };\n\n  // Rotate this vector (counter-clockwise) by the specified angle (in radians).\n  /**\n   * @param {number} angle The angle to rotate (in radians)\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['rotate'] = Vector.prototype.rotate = function (angle) {\n    var x = this['x'];\n    var y = this['y'];\n    this['x'] = x * Math.cos(angle) - y * Math.sin(angle);\n    this['y'] = x * Math.sin(angle) + y * Math.cos(angle);\n    return this;\n  };\n\n  // Reverse this vector.\n  /**\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['reverse'] = Vector.prototype.reverse = function () {\n    this['x'] = -this['x'];\n    this['y'] = -this['y'];\n    return this;\n  };\n\n\n  // Normalize this vector.  (make it have length of `1`)\n  /**\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['normalize'] = Vector.prototype.normalize = function () {\n    var d = this.len();\n    if (d > 0) {\n      this['x'] = this['x'] / d;\n      this['y'] = this['y'] / d;\n    }\n    return this;\n  };\n\n  // Add another vector to this one.\n  /**\n   * @param {Vector} other The other Vector.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['add'] = Vector.prototype.add = function (other) {\n    this['x'] += other['x'];\n    this['y'] += other['y'];\n    return this;\n  };\n\n  // Subtract another vector from this one.\n  /**\n   * @param {Vector} other The other Vector.\n   * @return {Vector} This for chaiing.\n   */\n  Vector.prototype['sub'] = Vector.prototype.sub = function (other) {\n    this['x'] -= other['x'];\n    this['y'] -= other['y'];\n    return this;\n  };\n\n  // Scale this vector. An independent scaling factor can be provided\n  // for each axis, or a single scaling factor that will scale both `x` and `y`.\n  /**\n   * @param {number} x The scaling factor in the x direction.\n   * @param {?number=} y The scaling factor in the y direction.  If this\n   *   is not specified, the x scaling factor will be used.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['scale'] = Vector.prototype.scale = function (x, y) {\n    this['x'] *= x;\n    this['y'] *= typeof y != 'undefined' ? y : x;\n    return this;\n  };\n\n  // Project this vector on to another vector.\n  /**\n   * @param {Vector} other The vector to project onto.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['project'] = Vector.prototype.project = function (other) {\n    var amt = this.dot(other) / other.len2();\n    this['x'] = amt * other['x'];\n    this['y'] = amt * other['y'];\n    return this;\n  };\n\n  // Project this vector onto a vector of unit length. This is slightly more efficient\n  // than `project` when dealing with unit vectors.\n  /**\n   * @param {Vector} other The unit vector to project onto.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['projectN'] = Vector.prototype.projectN = function (other) {\n    var amt = this.dot(other);\n    this['x'] = amt * other['x'];\n    this['y'] = amt * other['y'];\n    return this;\n  };\n\n  // Reflect this vector on an arbitrary axis.\n  /**\n   * @param {Vector} axis The vector representing the axis.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['reflect'] = Vector.prototype.reflect = function (axis) {\n    var x = this['x'];\n    var y = this['y'];\n    this.project(axis).scale(2);\n    this['x'] -= x;\n    this['y'] -= y;\n    return this;\n  };\n\n  // Reflect this vector on an arbitrary axis (represented by a unit vector). This is\n  // slightly more efficient than `reflect` when dealing with an axis that is a unit vector.\n  /**\n   * @param {Vector} axis The unit vector representing the axis.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['reflectN'] = Vector.prototype.reflectN = function (axis) {\n    var x = this['x'];\n    var y = this['y'];\n    this.projectN(axis).scale(2);\n    this['x'] -= x;\n    this['y'] -= y;\n    return this;\n  };\n\n  // Get the dot product of this vector and another.\n  /**\n   * @param {Vector}  other The vector to dot this one against.\n   * @return {number} The dot product.\n   */\n  Vector.prototype['dot'] = Vector.prototype.dot = function (other) {\n    return this['x'] * other['x'] + this['y'] * other['y'];\n  };\n\n  // Get the squared length of this vector.\n  /**\n   * @return {number} The length^2 of this vector.\n   */\n  Vector.prototype['len2'] = Vector.prototype.len2 = function () {\n    return this.dot(this);\n  };\n\n  // Get the length of this vector.\n  /**\n   * @return {number} The length of this vector.\n   */\n  Vector.prototype['len'] = Vector.prototype.len = function () {\n    return Math.sqrt(this.len2());\n  };\n\n  // ## Circle\n  //\n  // Represents a circle with a position and a radius.\n\n  // Create a new circle, optionally passing in a position and/or radius. If no position\n  // is given, the circle will be at `(0,0)`. If no radius is provided, the circle will\n  // have a radius of `0`.\n  /**\n   * @param {Vector=} pos A vector representing the position of the center of the circle\n   * @param {?number=} r The radius of the circle\n   * @constructor\n   */\n  function Circle(pos, r) {\n    this['pos'] = pos || new Vector();\n    this['r'] = r || 0;\n    this['offset'] = new Vector();\n  }\n  SAT['Circle'] = Circle;\n\n  // Compute the axis-aligned bounding box (AABB) of this Circle.\n  //\n  // Note: Returns a _new_ `Box` each time you call this.\n  /**\n   * @return {Polygon} The AABB\n   */\n  Circle.prototype['getAABBAsBox'] = Circle.prototype.getAABBAsBox = function () {\n    var r = this['r'];\n    var corner = this['pos'].clone().add(this['offset']).sub(new Vector(r, r));\n    return new Box(corner, r * 2, r * 2);\n  };\n\n  // Compute the axis-aligned bounding box (AABB) of this Circle.\n  //\n  // Note: Returns a _new_ `Polygon` each time you call this.\n  /**\n   * @return {Polygon} The AABB\n   */\n  Circle.prototype['getAABB'] = Circle.prototype.getAABB = function () {\n    return this.getAABBAsBox().toPolygon();\n  };\n\n  // Set the current offset to apply to the radius.\n  /**\n   * @param {Vector} offset The new offset vector.\n   * @return {Circle} This for chaining.\n   */\n  Circle.prototype['setOffset'] = Circle.prototype.setOffset = function (offset) {\n    this['offset'] = offset;\n    return this;\n  };\n\n  // ## Polygon\n  //\n  // Represents a *convex* polygon with any number of points (specified in counter-clockwise order)\n  //\n  // Note: Do _not_ manually change the `points`, `angle`, or `offset` properties. Use the\n  // provided setters. Otherwise the calculated properties will not be updated correctly.\n  //\n  // `pos` can be changed directly.\n\n  // Create a new polygon, passing in a position vector, and an array of points (represented\n  // by vectors relative to the position vector). If no position is passed in, the position\n  // of the polygon will be `(0,0)`.\n  /**\n   * @param {Vector=} pos A vector representing the origin of the polygon. (all other\n   *   points are relative to this one)\n   * @param {Array<Vector>=} points An array of vectors representing the points in the polygon,\n   *   in counter-clockwise order.\n   * @constructor\n   */\n  function Polygon(pos, points) {\n    this['pos'] = pos || new Vector();\n    this['angle'] = 0;\n    this['offset'] = new Vector();\n    this.setPoints(points || []);\n  }\n  SAT['Polygon'] = Polygon;\n\n  // Set the points of the polygon. Any consecutive duplicate points will be combined.\n  //\n  // Note: The points are counter-clockwise *with respect to the coordinate system*.\n  // If you directly draw the points on a screen that has the origin at the top-left corner\n  // it will _appear_ visually that the points are being specified clockwise. This is just\n  // because of the inversion of the Y-axis when being displayed.\n  /**\n   * @param {Array<Vector>=} points An array of vectors representing the points in the polygon,\n   *   in counter-clockwise order.\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['setPoints'] = Polygon.prototype.setPoints = function (points) {\n    // Only re-allocate if this is a new polygon or the number of points has changed.\n    var lengthChanged = !this['points'] || this['points'].length !== points.length;\n    if (lengthChanged) {\n      var i;\n      var calcPoints = this['calcPoints'] = [];\n      var edges = this['edges'] = [];\n      var normals = this['normals'] = [];\n      // Allocate the vector arrays for the calculated properties\n      for (i = 0; i < points.length; i++) {\n        // Remove consecutive duplicate points\n        var p1 = points[i];\n        var p2 = i < points.length - 1 ? points[i + 1] : points[0];\n        if (p1 !== p2 && p1.x === p2.x && p1.y === p2.y) {\n          points.splice(i, 1);\n          i -= 1;\n          continue;\n        }\n        calcPoints.push(new Vector());\n        edges.push(new Vector());\n        normals.push(new Vector());\n      }\n    }\n    this['points'] = points;\n    this._recalc();\n    return this;\n  };\n\n  // Set the current rotation angle of the polygon.\n  /**\n   * @param {number} angle The current rotation angle (in radians).\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['setAngle'] = Polygon.prototype.setAngle = function (angle) {\n    this['angle'] = angle;\n    this._recalc();\n    return this;\n  };\n\n  // Set the current offset to apply to the `points` before applying the `angle` rotation.\n  /**\n   * @param {Vector} offset The new offset vector.\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['setOffset'] = Polygon.prototype.setOffset = function (offset) {\n    this['offset'] = offset;\n    this._recalc();\n    return this;\n  };\n\n  // Rotates this polygon counter-clockwise around the origin of *its local coordinate system* (i.e. `pos`).\n  //\n  // Note: This changes the **original** points (so any `angle` will be applied on top of this rotation).\n  /**\n   * @param {number} angle The angle to rotate (in radians)\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['rotate'] = Polygon.prototype.rotate = function (angle) {\n    var points = this['points'];\n    var len = points.length;\n    for (var i = 0; i < len; i++) {\n      points[i].rotate(angle);\n    }\n    this._recalc();\n    return this;\n  };\n\n  // Translates the points of this polygon by a specified amount relative to the origin of *its own coordinate\n  // system* (i.e. `pos`).\n  //\n  // This is most useful to change the \"center point\" of a polygon. If you just want to move the whole polygon, change\n  // the coordinates of `pos`.\n  //\n  // Note: This changes the **original** points (so any `offset` will be applied on top of this translation)\n  /**\n   * @param {number} x The horizontal amount to translate.\n   * @param {number} y The vertical amount to translate.\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['translate'] = Polygon.prototype.translate = function (x, y) {\n    var points = this['points'];\n    var len = points.length;\n    for (var i = 0; i < len; i++) {\n      points[i]['x'] += x;\n      points[i]['y'] += y;\n    }\n    this._recalc();\n    return this;\n  };\n\n\n  // Computes the calculated collision polygon. Applies the `angle` and `offset` to the original points then recalculates the\n  // edges and normals of the collision polygon.\n  /**\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype._recalc = function () {\n    // Calculated points - this is what is used for underlying collisions and takes into account\n    // the angle/offset set on the polygon.\n    var calcPoints = this['calcPoints'];\n    // The edges here are the direction of the `n`th edge of the polygon, relative to\n    // the `n`th point. If you want to draw a given edge from the edge value, you must\n    // first translate to the position of the starting point.\n    var edges = this['edges'];\n    // The normals here are the direction of the normal for the `n`th edge of the polygon, relative\n    // to the position of the `n`th point. If you want to draw an edge normal, you must first\n    // translate to the position of the starting point.\n    var normals = this['normals'];\n    // Copy the original points array and apply the offset/angle\n    var points = this['points'];\n    var offset = this['offset'];\n    var angle = this['angle'];\n    var len = points.length;\n    var i;\n    for (i = 0; i < len; i++) {\n      var calcPoint = calcPoints[i].copy(points[i]);\n      calcPoint['x'] += offset['x'];\n      calcPoint['y'] += offset['y'];\n      if (angle !== 0) {\n        calcPoint.rotate(angle);\n      }\n    }\n    // Calculate the edges/normals\n    for (i = 0; i < len; i++) {\n      var p1 = calcPoints[i];\n      var p2 = i < len - 1 ? calcPoints[i + 1] : calcPoints[0];\n      var e = edges[i].copy(p2).sub(p1);\n      normals[i].copy(e).perp().normalize();\n    }\n    return this;\n  };\n\n\n  // Compute the axis-aligned bounding box. Any current state\n  // (translations/rotations) will be applied before constructing the AABB.\n  //\n  // Note: Returns a _new_ `Box` each time you call this.\n  /**\n   * @return {Polygon} The AABB\n   */\n  Polygon.prototype['getAABBAsBox'] = Polygon.prototype.getAABBAsBox = function () {\n    var points = this['calcPoints'];\n    var len = points.length;\n    var xMin = points[0]['x'];\n    var yMin = points[0]['y'];\n    var xMax = points[0]['x'];\n    var yMax = points[0]['y'];\n    for (var i = 1; i < len; i++) {\n      var point = points[i];\n      if (point['x'] < xMin) {\n        xMin = point['x'];\n      }\n      else if (point['x'] > xMax) {\n        xMax = point['x'];\n      }\n      if (point['y'] < yMin) {\n        yMin = point['y'];\n      }\n      else if (point['y'] > yMax) {\n        yMax = point['y'];\n      }\n    }\n    return new Box(this['pos'].clone().add(new Vector(xMin, yMin)), xMax - xMin, yMax - yMin);\n  };\n\n\n  // Compute the axis-aligned bounding box. Any current state\n  // (translations/rotations) will be applied before constructing the AABB.\n  //\n  // Note: Returns a _new_ `Polygon` each time you call this.\n  /**\n   * @return {Polygon} The AABB\n   */\n  Polygon.prototype['getAABB'] = Polygon.prototype.getAABB = function () {\n    return this.getAABBAsBox().toPolygon();\n  };\n\n  // Compute the centroid (geometric center) of the polygon. Any current state\n  // (translations/rotations) will be applied before computing the centroid.\n  //\n  // See https://en.wikipedia.org/wiki/Centroid#Centroid_of_a_polygon\n  //\n  // Note: Returns a _new_ `Vector` each time you call this.\n  /**\n   * @return {Vector} A Vector that contains the coordinates of the Centroid.\n   */\n  Polygon.prototype['getCentroid'] = Polygon.prototype.getCentroid = function () {\n    var points = this['calcPoints'];\n    var len = points.length;\n    var cx = 0;\n    var cy = 0;\n    var ar = 0;\n    for (var i = 0; i < len; i++) {\n      var p1 = points[i];\n      var p2 = i === len - 1 ? points[0] : points[i + 1]; // Loop around if last point\n      var a = p1['x'] * p2['y'] - p2['x'] * p1['y'];\n      cx += (p1['x'] + p2['x']) * a;\n      cy += (p1['y'] + p2['y']) * a;\n      ar += a;\n    }\n    ar = ar * 3; // we want 1 / 6 the area and we currently have 2*area\n    cx = cx / ar;\n    cy = cy / ar;\n    return new Vector(cx, cy);\n  };\n\n\n  // ## Box\n  //\n  // Represents an axis-aligned box, with a width and height.\n\n\n  // Create a new box, with the specified position, width, and height. If no position\n  // is given, the position will be `(0,0)`. If no width or height are given, they will\n  // be set to `0`.\n  /**\n   * @param {Vector=} pos A vector representing the bottom-left of the box (i.e. the smallest x and smallest y value).\n   * @param {?number=} w The width of the box.\n   * @param {?number=} h The height of the box.\n   * @constructor\n   */\n  function Box(pos, w, h) {\n    this['pos'] = pos || new Vector();\n    this['w'] = w || 0;\n    this['h'] = h || 0;\n  }\n  SAT['Box'] = Box;\n\n  // Returns a polygon whose edges are the same as this box.\n  /**\n   * @return {Polygon} A new Polygon that represents this box.\n   */\n  Box.prototype['toPolygon'] = Box.prototype.toPolygon = function () {\n    var pos = this['pos'];\n    var w = this['w'];\n    var h = this['h'];\n    return new Polygon(new Vector(pos['x'], pos['y']), [\n      new Vector(), new Vector(w, 0),\n      new Vector(w, h), new Vector(0, h)\n    ]);\n  };\n\n  // ## Response\n  //\n  // An object representing the result of an intersection. Contains:\n  //  - The two objects participating in the intersection\n  //  - The vector representing the minimum change necessary to extract the first object\n  //    from the second one (as well as a unit vector in that direction and the magnitude\n  //    of the overlap)\n  //  - Whether the first object is entirely inside the second, and vice versa.\n  /**\n   * @constructor\n   */\n  function Response() {\n    this['a'] = null;\n    this['b'] = null;\n    this['overlapN'] = new Vector();\n    this['overlapV'] = new Vector();\n    this.clear();\n  }\n  SAT['Response'] = Response;\n\n  // Set some values of the response back to their defaults.  Call this between tests if\n  // you are going to reuse a single Response object for multiple intersection tests (recommented\n  // as it will avoid allcating extra memory)\n  /**\n   * @return {Response} This for chaining\n   */\n  Response.prototype['clear'] = Response.prototype.clear = function () {\n    this['aInB'] = true;\n    this['bInA'] = true;\n    this['overlap'] = Number.MAX_VALUE;\n    return this;\n  };\n\n  // ## Object Pools\n\n  // A pool of `Vector` objects that are used in calculations to avoid\n  // allocating memory.\n  /**\n   * @type {Array<Vector>}\n   */\n  var T_VECTORS = [];\n  for (var i = 0; i < 10; i++) { T_VECTORS.push(new Vector()); }\n\n  // A pool of arrays of numbers used in calculations to avoid allocating\n  // memory.\n  /**\n   * @type {Array<Array<number>>}\n   */\n  var T_ARRAYS = [];\n  for (var i = 0; i < 5; i++) { T_ARRAYS.push([]); }\n\n  // Temporary response used for polygon hit detection.\n  /**\n   * @type {Response}\n   */\n  var T_RESPONSE = new Response();\n\n  // Tiny \"point\" polygon used for polygon hit detection.\n  /**\n   * @type {Polygon}\n   */\n  var TEST_POINT = new Box(new Vector(), 0.000001, 0.000001).toPolygon();\n\n  // ## Helper Functions\n\n  // Flattens the specified array of points onto a unit vector axis,\n  // resulting in a one dimensional range of the minimum and\n  // maximum value on that axis.\n  /**\n   * @param {Array<Vector>} points The points to flatten.\n   * @param {Vector} normal The unit vector axis to flatten on.\n   * @param {Array<number>} result An array.  After calling this function,\n   *   result[0] will be the minimum value,\n   *   result[1] will be the maximum value.\n   */\n  function flattenPointsOn(points, normal, result) {\n    var min = Number.MAX_VALUE;\n    var max = -Number.MAX_VALUE;\n    var len = points.length;\n    for (var i = 0; i < len; i++) {\n      // The magnitude of the projection of the point onto the normal\n      var dot = points[i].dot(normal);\n      if (dot < min) { min = dot; }\n      if (dot > max) { max = dot; }\n    }\n    result[0] = min; result[1] = max;\n  }\n\n  // Check whether two convex polygons are separated by the specified\n  // axis (must be a unit vector).\n  /**\n   * @param {Vector} aPos The position of the first polygon.\n   * @param {Vector} bPos The position of the second polygon.\n   * @param {Array<Vector>} aPoints The points in the first polygon.\n   * @param {Array<Vector>} bPoints The points in the second polygon.\n   * @param {Vector} axis The axis (unit sized) to test against.  The points of both polygons\n   *   will be projected onto this axis.\n   * @param {Response=} response A Response object (optional) which will be populated\n   *   if the axis is not a separating axis.\n   * @return {boolean} true if it is a separating axis, false otherwise.  If false,\n   *   and a response is passed in, information about how much overlap and\n   *   the direction of the overlap will be populated.\n   */\n  function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {\n    var rangeA = T_ARRAYS.pop();\n    var rangeB = T_ARRAYS.pop();\n    // The magnitude of the offset between the two polygons\n    var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);\n    var projectedOffset = offsetV.dot(axis);\n    // Project the polygons onto the axis.\n    flattenPointsOn(aPoints, axis, rangeA);\n    flattenPointsOn(bPoints, axis, rangeB);\n    // Move B's range to its position relative to A.\n    rangeB[0] += projectedOffset;\n    rangeB[1] += projectedOffset;\n    // Check if there is a gap. If there is, this is a separating axis and we can stop\n    if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {\n      T_VECTORS.push(offsetV);\n      T_ARRAYS.push(rangeA);\n      T_ARRAYS.push(rangeB);\n      return true;\n    }\n    // This is not a separating axis. If we're calculating a response, calculate the overlap.\n    if (response) {\n      var overlap = 0;\n      // A starts further left than B\n      if (rangeA[0] < rangeB[0]) {\n        response['aInB'] = false;\n        // A ends before B does. We have to pull A out of B\n        if (rangeA[1] < rangeB[1]) {\n          overlap = rangeA[1] - rangeB[0];\n          response['bInA'] = false;\n          // B is fully inside A.  Pick the shortest way out.\n        } else {\n          var option1 = rangeA[1] - rangeB[0];\n          var option2 = rangeB[1] - rangeA[0];\n          overlap = option1 < option2 ? option1 : -option2;\n        }\n        // B starts further left than A\n      } else {\n        response['bInA'] = false;\n        // B ends before A ends. We have to push A out of B\n        if (rangeA[1] > rangeB[1]) {\n          overlap = rangeA[0] - rangeB[1];\n          response['aInB'] = false;\n          // A is fully inside B.  Pick the shortest way out.\n        } else {\n          var option1 = rangeA[1] - rangeB[0];\n          var option2 = rangeB[1] - rangeA[0];\n          overlap = option1 < option2 ? option1 : -option2;\n        }\n      }\n      // If this is the smallest amount of overlap we've seen so far, set it as the minimum overlap.\n      var absOverlap = Math.abs(overlap);\n      if (absOverlap < response['overlap']) {\n        response['overlap'] = absOverlap;\n        response['overlapN'].copy(axis);\n        if (overlap < 0) {\n          response['overlapN'].reverse();\n        }\n      }\n    }\n    T_VECTORS.push(offsetV);\n    T_ARRAYS.push(rangeA);\n    T_ARRAYS.push(rangeB);\n    return false;\n  }\n  SAT['isSeparatingAxis'] = isSeparatingAxis;\n\n  // Calculates which Voronoi region a point is on a line segment.\n  // It is assumed that both the line and the point are relative to `(0,0)`\n  //\n  //            |       (0)      |\n  //     (-1)  [S]--------------[E]  (1)\n  //            |       (0)      |\n  /**\n   * @param {Vector} line The line segment.\n   * @param {Vector} point The point.\n   * @return  {number} LEFT_VORONOI_REGION (-1) if it is the left region,\n   *          MIDDLE_VORONOI_REGION (0) if it is the middle region,\n   *          RIGHT_VORONOI_REGION (1) if it is the right region.\n   */\n  function voronoiRegion(line, point) {\n    var len2 = line.len2();\n    var dp = point.dot(line);\n    // If the point is beyond the start of the line, it is in the\n    // left voronoi region.\n    if (dp < 0) { return LEFT_VORONOI_REGION; }\n    // If the point is beyond the end of the line, it is in the\n    // right voronoi region.\n    else if (dp > len2) { return RIGHT_VORONOI_REGION; }\n    // Otherwise, it's in the middle one.\n    else { return MIDDLE_VORONOI_REGION; }\n  }\n  // Constants for Voronoi regions\n  /**\n   * @const\n   */\n  var LEFT_VORONOI_REGION = -1;\n  /**\n   * @const\n   */\n  var MIDDLE_VORONOI_REGION = 0;\n  /**\n   * @const\n   */\n  var RIGHT_VORONOI_REGION = 1;\n\n  // ## Collision Tests\n\n  // Check if a point is inside a circle.\n  /**\n   * @param {Vector} p The point to test.\n   * @param {Circle} c The circle to test.\n   * @return {boolean} true if the point is inside the circle, false if it is not.\n   */\n  function pointInCircle(p, c) {\n    var differenceV = T_VECTORS.pop().copy(p).sub(c['pos']).sub(c['offset']);\n    var radiusSq = c['r'] * c['r'];\n    var distanceSq = differenceV.len2();\n    T_VECTORS.push(differenceV);\n    // If the distance between is smaller than the radius then the point is inside the circle.\n    return distanceSq <= radiusSq;\n  }\n  SAT['pointInCircle'] = pointInCircle;\n\n  // Check if a point is inside a convex polygon.\n  /**\n   * @param {Vector} p The point to test.\n   * @param {Polygon} poly The polygon to test.\n   * @return {boolean} true if the point is inside the polygon, false if it is not.\n   */\n  function pointInPolygon(p, poly) {\n    TEST_POINT['pos'].copy(p);\n    T_RESPONSE.clear();\n    var result = testPolygonPolygon(TEST_POINT, poly, T_RESPONSE);\n    if (result) {\n      result = T_RESPONSE['aInB'];\n    }\n    return result;\n  }\n  SAT['pointInPolygon'] = pointInPolygon;\n\n  // Check if two circles collide.\n  /**\n   * @param {Circle} a The first circle.\n   * @param {Circle} b The second circle.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   the circles intersect.\n   * @return {boolean} true if the circles intersect, false if they don't.\n   */\n  function testCircleCircle(a, b, response) {\n    // Check if the distance between the centers of the two\n    // circles is greater than their combined radius.\n    var differenceV = T_VECTORS.pop().copy(b['pos']).add(b['offset']).sub(a['pos']).sub(a['offset']);\n    var totalRadius = a['r'] + b['r'];\n    var totalRadiusSq = totalRadius * totalRadius;\n    var distanceSq = differenceV.len2();\n    // If the distance is bigger than the combined radius, they don't intersect.\n    if (distanceSq > totalRadiusSq) {\n      T_VECTORS.push(differenceV);\n      return false;\n    }\n    // They intersect.  If we're calculating a response, calculate the overlap.\n    if (response) {\n      var dist = Math.sqrt(distanceSq);\n      response['a'] = a;\n      response['b'] = b;\n      response['overlap'] = totalRadius - dist;\n      response['overlapN'].copy(differenceV.normalize());\n      response['overlapV'].copy(differenceV).scale(response['overlap']);\n      response['aInB'] = a['r'] <= b['r'] && dist <= b['r'] - a['r'];\n      response['bInA'] = b['r'] <= a['r'] && dist <= a['r'] - b['r'];\n    }\n    T_VECTORS.push(differenceV);\n    return true;\n  }\n  SAT['testCircleCircle'] = testCircleCircle;\n\n  // Check if a polygon and a circle collide.\n  /**\n   * @param {Polygon} polygon The polygon.\n   * @param {Circle} circle The circle.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testPolygonCircle(polygon, circle, response) {\n    // Get the position of the circle relative to the polygon.\n    var circlePos = T_VECTORS.pop().copy(circle['pos']).add(circle['offset']).sub(polygon['pos']);\n    var radius = circle['r'];\n    var radius2 = radius * radius;\n    var points = polygon['calcPoints'];\n    var len = points.length;\n    var edge = T_VECTORS.pop();\n    var point = T_VECTORS.pop();\n\n    // For each edge in the polygon:\n    for (var i = 0; i < len; i++) {\n      var next = i === len - 1 ? 0 : i + 1;\n      var prev = i === 0 ? len - 1 : i - 1;\n      var overlap = 0;\n      var overlapN = null;\n\n      // Get the edge.\n      edge.copy(polygon['edges'][i]);\n      // Calculate the center of the circle relative to the starting point of the edge.\n      point.copy(circlePos).sub(points[i]);\n\n      // If the distance between the center of the circle and the point\n      // is bigger than the radius, the polygon is definitely not fully in\n      // the circle.\n      if (response && point.len2() > radius2) {\n        response['aInB'] = false;\n      }\n\n      // Calculate which Voronoi region the center of the circle is in.\n      var region = voronoiRegion(edge, point);\n      // If it's the left region:\n      if (region === LEFT_VORONOI_REGION) {\n        // We need to make sure we're in the RIGHT_VORONOI_REGION of the previous edge.\n        edge.copy(polygon['edges'][prev]);\n        // Calculate the center of the circle relative the starting point of the previous edge\n        var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);\n        region = voronoiRegion(edge, point2);\n        if (region === RIGHT_VORONOI_REGION) {\n          // It's in the region we want.  Check if the circle intersects the point.\n          var dist = point.len();\n          if (dist > radius) {\n            // No intersection\n            T_VECTORS.push(circlePos);\n            T_VECTORS.push(edge);\n            T_VECTORS.push(point);\n            T_VECTORS.push(point2);\n            return false;\n          } else if (response) {\n            // It intersects, calculate the overlap.\n            response['bInA'] = false;\n            overlapN = point.normalize();\n            overlap = radius - dist;\n          }\n        }\n        T_VECTORS.push(point2);\n        // If it's the right region:\n      } else if (region === RIGHT_VORONOI_REGION) {\n        // We need to make sure we're in the left region on the next edge\n        edge.copy(polygon['edges'][next]);\n        // Calculate the center of the circle relative to the starting point of the next edge.\n        point.copy(circlePos).sub(points[next]);\n        region = voronoiRegion(edge, point);\n        if (region === LEFT_VORONOI_REGION) {\n          // It's in the region we want.  Check if the circle intersects the point.\n          var dist = point.len();\n          if (dist > radius) {\n            // No intersection\n            T_VECTORS.push(circlePos);\n            T_VECTORS.push(edge);\n            T_VECTORS.push(point);\n            return false;\n          } else if (response) {\n            // It intersects, calculate the overlap.\n            response['bInA'] = false;\n            overlapN = point.normalize();\n            overlap = radius - dist;\n          }\n        }\n        // Otherwise, it's the middle region:\n      } else {\n        // Need to check if the circle is intersecting the edge,\n        // Change the edge into its \"edge normal\".\n        var normal = edge.perp().normalize();\n        // Find the perpendicular distance between the center of the\n        // circle and the edge.\n        var dist = point.dot(normal);\n        var distAbs = Math.abs(dist);\n        // If the circle is on the outside of the edge, there is no intersection.\n        if (dist > 0 && distAbs > radius) {\n          // No intersection\n          T_VECTORS.push(circlePos);\n          T_VECTORS.push(normal);\n          T_VECTORS.push(point);\n          return false;\n        } else if (response) {\n          // It intersects, calculate the overlap.\n          overlapN = normal;\n          overlap = radius - dist;\n          // If the center of the circle is on the outside of the edge, or part of the\n          // circle is on the outside, the circle is not fully inside the polygon.\n          if (dist >= 0 || overlap < 2 * radius) {\n            response['bInA'] = false;\n          }\n        }\n      }\n\n      // If this is the smallest overlap we've seen, keep it.\n      // (overlapN may be null if the circle was in the wrong Voronoi region).\n      if (overlapN && response && Math.abs(overlap) < Math.abs(response['overlap'])) {\n        response['overlap'] = overlap;\n        response['overlapN'].copy(overlapN);\n      }\n    }\n\n    // Calculate the final overlap vector - based on the smallest overlap.\n    if (response) {\n      response['a'] = polygon;\n      response['b'] = circle;\n      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);\n    }\n    T_VECTORS.push(circlePos);\n    T_VECTORS.push(edge);\n    T_VECTORS.push(point);\n    return true;\n  }\n  SAT['testPolygonCircle'] = testPolygonCircle;\n\n  // Check if a circle and a polygon collide.\n  //\n  // **NOTE:** This is slightly less efficient than polygonCircle as it just\n  // runs polygonCircle and reverses everything at the end.\n  /**\n   * @param {Circle} circle The circle.\n   * @param {Polygon} polygon The polygon.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testCirclePolygon(circle, polygon, response) {\n    // Test the polygon against the circle.\n    var result = testPolygonCircle(polygon, circle, response);\n    if (result && response) {\n      // Swap A and B in the response.\n      var a = response['a'];\n      var aInB = response['aInB'];\n      response['overlapN'].reverse();\n      response['overlapV'].reverse();\n      response['a'] = response['b'];\n      response['b'] = a;\n      response['aInB'] = response['bInA'];\n      response['bInA'] = aInB;\n    }\n    return result;\n  }\n  SAT['testCirclePolygon'] = testCirclePolygon;\n\n  // Checks whether polygons collide.\n  /**\n   * @param {Polygon} a The first polygon.\n   * @param {Polygon} b The second polygon.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testPolygonPolygon(a, b, response) {\n    var aPoints = a['calcPoints'];\n    var aLen = aPoints.length;\n    var bPoints = b['calcPoints'];\n    var bLen = bPoints.length;\n    // If any of the edge normals of A is a separating axis, no intersection.\n    for (var i = 0; i < aLen; i++) {\n      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, a['normals'][i], response)) {\n        return false;\n      }\n    }\n    // If any of the edge normals of B is a separating axis, no intersection.\n    for (var i = 0; i < bLen; i++) {\n      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, b['normals'][i], response)) {\n        return false;\n      }\n    }\n    // Since none of the edge normals of A or B are a separating axis, there is an intersection\n    // and we've already calculated the smallest overlap (in isSeparatingAxis).  Calculate the\n    // final overlap vector.\n    if (response) {\n      response['a'] = a;\n      response['b'] = b;\n      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);\n    }\n    return true;\n  }\n  SAT['testPolygonPolygon'] = testPolygonPolygon;\n\n  return SAT;\n}));\n","import { Box, Vector } from \"sat\";\r\nimport { MapComponent } from \"./component\";\r\n\r\nexport type HouseType = InstanceType<typeof House>;\r\n\r\ntype ColorSet = {c1: string, c2: string, c3: string};\r\n\r\nconst COLORS: ColorSet[] = [\r\n  {c1: '#bf6040', c2: '#a25134', c3: '#8b452b'},\r\n  {c1: '#b3bdbe', c2: '#94999d', c3: '#757a7d'},\r\n  {c1: '#7499b6', c2: '#4d667c', c3: '#62809c'},\r\n  // {c1: '#FFB841', c2: '#E78F10', c3: '#FF9608'},\r\n  // {c1: '#FD8D5A', c2: '#E46E41', c3: '#F07A50'},\r\n];\r\n\r\nexport default class House implements MapComponent {\r\n  private x: number;\r\n  private y: number;\r\n  private width: number;\r\n  private height: number;\r\n  private entranceDir: number;\r\n  public box: Box;\r\n  private colorSet: ColorSet;\r\n\r\n  constructor(x: number, y: number, width: number, height: number, entranceDir: number) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = width;\r\n    this.height = height;\r\n    this.entranceDir = entranceDir;\r\n    this.box = new Box(new Vector(x, y), width, height);\r\n    this.colorSet = COLORS[Math.floor(Math.random() * COLORS.length)];\r\n  }\r\n\r\n  draw(context: CanvasRenderingContext2D): void {\r\n    switch (this.entranceDir) {\r\n      case 0:\r\n      case 2:\r\n        context.fillStyle = this.colorSet.c2;\r\n        context.fillRect(this.x, this.y, this.width, this.height / 2);\r\n        context.fillStyle = this.colorSet.c3;\r\n        context.fillRect(this.x, this.y + this.height / 2, this.width, this.height / 2);\r\n        context.fillStyle = this.colorSet.c1;\r\n        context.beginPath();\r\n        context.moveTo(this.x, this.y);\r\n        context.lineTo(this.x, this.y + this.height);\r\n        context.lineTo(this.x + this.width / 4, this.y + this.height / 2);\r\n        context.lineTo(this.x, this.y);\r\n        context.moveTo(this.x + this.width, this.y);\r\n        context.lineTo(this.x + this.width - this.width / 4, this.y + this.height / 2);\r\n        context.lineTo(this.x + this.width, this.y + this.height);\r\n        context.lineTo(this.x + this.width, this.y);\r\n        context.fill();\r\n        break;\r\n      case 1:\r\n      case 3:\r\n        context.fillStyle = this.colorSet.c2;\r\n        context.fillRect(this.x, this.y, this.width / 2, this.height);\r\n        context.fillStyle = this.colorSet.c3;\r\n        context.fillRect(this.x + this.width / 2, this.y, this.width / 2, this.height);\r\n        context.fillStyle = this.colorSet.c1;\r\n        context.beginPath();\r\n        context.moveTo(this.x, this.y);\r\n        context.lineTo(this.x + this.width, this.y);\r\n        context.lineTo(this.x + this.width / 2, this.y + this.height / 4);\r\n        context.lineTo(this.x, this.y);\r\n        context.moveTo(this.x, this.y + this.height);\r\n        context.lineTo(this.x + this.width / 2, this.y + this.height - this.height / 4);\r\n        context.lineTo(this.x + this.width, this.y + this.height);\r\n        context.lineTo(this.x, this.y + this.height);\r\n        context.fill();\r\n        break;\r\n    }\r\n  }\r\n\r\n  update (deltaTime: number): void {}\r\n\r\n  getBox(): Box {\r\n    return this.box;\r\n  }\r\n}\r\n","import { Polygon, testPolygonPolygon } from \"sat\";\r\nimport { MapComponent } from \"./component\";\r\nimport Floor from \"./floor\";\r\n\r\nexport default class Map {\r\n  private components: MapComponent[] = [];\r\n  private floor?: Floor;\r\n\r\n  public add (component: MapComponent): void {\r\n    this.components.push(component);\r\n  }\r\n\r\n  public setFloor (floor: Floor): void {\r\n    this.floor = floor;\r\n  }\r\n\r\n  public update (deltaTime: number):void {\r\n    for (const c of this.components) {\r\n      c.update(deltaTime);\r\n    }\r\n  }\r\n\r\n  public draw(context: CanvasRenderingContext2D): void {\r\n    if (this.floor) {\r\n      this.floor.draw(context);\r\n    }\r\n\r\n    for (const c of this.components) {\r\n      c.draw(context);\r\n    }\r\n  }\r\n  \r\n  public checkCollision (polygon: Polygon): boolean {\r\n    for (const c of this.components) {\r\n      const box = c.getBox();\r\n      if (box && testPolygonPolygon(polygon, box.toPolygon())) {\r\n        return true;\r\n      };\r\n    }\r\n    return false;\r\n  }\r\n}\r\n","import { MapComponent } from \"./component\";\r\n\r\nexport type Point = {\r\n  x: number;\r\n  y: number;\r\n};\r\n\r\nexport default class Road implements MapComponent {\r\n  private points: Point[];\r\n  private path: Path2D;\r\n\r\n  constructor(points: Point[]) {\r\n    this.points = points;\r\n    this.path = new Path2D();\r\n    this.path.moveTo(this.points[0].x, this.points[0].y);\r\n    for (const point of this.points) {\r\n      this.path.lineTo(point.x, point.y);\r\n    }\r\n  }\r\n\r\n  getBox(): void {}\r\n\r\n  draw(context: CanvasRenderingContext2D): void {\r\n    // L√≥gica para desenhar uma estrada no contexto do canvas\r\n    context.setLineDash([]);\r\n    context.lineWidth = 92;\r\n    context.strokeStyle = '#D2D1CD';\r\n    context.stroke(this.path);\r\n    //\r\n    context.lineWidth = 84;\r\n    context.strokeStyle = '#2A2922';\r\n    context.stroke(this.path);\r\n    //\r\n    context.setLineDash([5, 15]);\r\n    context.lineWidth = 2;\r\n    context.strokeStyle = '#FFFFFF';\r\n    context.stroke(this.path);\r\n  }\r\n\r\n  update (deltaTime: number): void {}\r\n}\r\n","import { MapComponent } from \"./component\";\r\n\r\nexport default class Wall implements MapComponent {\r\n  private x: number;\r\n  private y: number;\r\n  private width: number;\r\n  private height: number;\r\n  private entranceDir: number;\r\n\r\n  constructor(x: number, y: number, width: number, height: number, entranceDir: number = 0) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = width;\r\n    this.height = height;\r\n    this.entranceDir = entranceDir;\r\n  }\r\n\r\n  getBox(): void {}\r\n\r\n  draw(context: CanvasRenderingContext2D): void {\r\n    context.strokeStyle = '#BC4A3C';\r\n    context.setLineDash([]);\r\n    context.lineWidth = 2;\r\n    context.strokeRect(this.x, this.y, this.width, this.height);\r\n    context.setLineDash([5, 2]);\r\n    context.lineWidth = 4;\r\n    context.strokeRect(this.x, this.y, this.width, this.height);\r\n    context.setLineDash([]);\r\n    context.fillStyle = '#BC4A3C';\r\n    context.lineWidth = 1;\r\n    context.fillRect(this.x - 4, this.y - 4, 8, 8);\r\n    context.fillRect(this.x - 4 + this.width, this.y - 4, 8, 8);\r\n    context.fillRect(this.x - 4, this.y - 4 + this.height, 8, 8);\r\n    context.fillRect(this.x - 4 + this.width, this.y - 4 + this.height, 8, 8);\r\n\r\n    const entranceLength = 30;\r\n    context.fillStyle = '#9b7653';\r\n    switch (this.entranceDir) {\r\n      case 0:\r\n        context.fillRect(\r\n          this.x + this.width / 2 - entranceLength / 2,\r\n          this.y - 2,\r\n          entranceLength,\r\n          4\r\n        );\r\n        break;\r\n      case 1:\r\n        context.fillRect(\r\n          this.x + this.width - 2,\r\n          this.y + this.height / 2 - entranceLength / 2,\r\n          4,\r\n          entranceLength\r\n        );\r\n        break;\r\n      case 2:\r\n        context.fillRect(\r\n          this.x + this.width / 2 - entranceLength / 2,\r\n          this.y + this.height - 2,\r\n          entranceLength,\r\n          4\r\n        );\r\n        break;\r\n      case 3:\r\n        context.fillRect(\r\n          this.x - 2,\r\n          this.y + this.height / 2 - entranceLength / 2,\r\n          4,\r\n          entranceLength\r\n        );\r\n        break;\r\n    }\r\n  }\r\n\r\n  update (deltaTime: number): void {}\r\n}\r\n","import { Box, Vector } from \"sat\";\r\nimport { MapComponent } from \"./component\";\r\nimport House from \"./house\";\r\nimport Wall from \"./wall\";\r\n\r\nexport default class Terrain implements MapComponent {\r\n  private x: number;\r\n  private y: number;\r\n  private width: number;\r\n  private height: number;\r\n  private components: MapComponent[] = [];\r\n  private box: Box;\r\n\r\n  constructor(x: number, y: number, width: number, height: number) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = width;\r\n    this.height = height;\r\n    this.box = new Box(new Vector(x, y), width, height);\r\n  }\r\n\r\n  draw(context: CanvasRenderingContext2D): void {\r\n    context.fillStyle = '#9b7653';\r\n    context.fillRect(this.x, this.y, this.width, this.height);\r\n    for (const c of this.components) {\r\n      c.draw(context);\r\n    }\r\n  }\r\n\r\n  update (deltaTime: number): void {}\r\n\r\n  addWall ({entranceDir}: {entranceDir: number}): void {\r\n    const wall = new Wall(this.x, this.y, this.width, this.height, entranceDir);\r\n    this.components.push(wall);\r\n  }\r\n\r\n  addHouse ({x, y, width, height, entranceDir}: {x: number, y: number, width: number, height: number, entranceDir: number}): void {\r\n    const house = new House(this.x + x, this.y + y, width, height, entranceDir);\r\n    this.components.push(house);\r\n  }\r\n\r\n  getBox(): Box {\r\n    return this.box;\r\n  }\r\n}\r\n","import TrafficSignal from \"./trafficSignal\";\r\n\r\nexport enum trafficSignalStates {\r\n  RED, YELLOW, GREEN\r\n};\r\n\r\nexport abstract class TrafficSignalState {\r\n  protected ts: TrafficSignal;\r\n  constructor (ts: TrafficSignal) {\r\n    this.ts = ts;\r\n  }\r\n\r\n  abstract enter (): void;\r\n  abstract next (): void;\r\n}\r\n\r\nexport class TrafficSignalRed extends TrafficSignalState {\r\n  enter () {\r\n    this.ts.maxTime = 5000;\r\n    this.ts.time = 0;\r\n  }\r\n\r\n  next (): void {\r\n    this.ts.setState(trafficSignalStates.GREEN);\r\n  }\r\n}\r\n\r\nexport class TrafficSignalGreen extends TrafficSignalState {\r\n  enter () {\r\n    this.ts.maxTime = 3000;\r\n    this.ts.time = 0;\r\n  }\r\n\r\n  next (): void {\r\n    this.ts.setState(trafficSignalStates.YELLOW);\r\n  }\r\n}\r\n\r\nexport class TrafficSignalYellow extends TrafficSignalState {\r\n  enter () {\r\n    this.ts.maxTime = 2000;\r\n    this.ts.time = 0;\r\n  }\r\n\r\n  next (): void {\r\n    this.ts.setState(trafficSignalStates.RED);\r\n  }\r\n}\r\n","import { Box, Vector } from \"sat\";\r\nimport { MapComponent } from \"./component\";\r\nimport {\r\n  TrafficSignalGreen,\r\n  TrafficSignalRed,\r\n  TrafficSignalState,\r\n  TrafficSignalYellow,\r\n  trafficSignalStates,\r\n} from \"./trafficSinalStates\";\r\n\r\nexport default class TrafficSignal implements MapComponent {\r\n  private x: number;\r\n  private y: number;\r\n  private width: number;\r\n  private height: number;\r\n  private dir: number;\r\n  public time: number;\r\n  public maxTime: number;\r\n  private box: Box;\r\n\r\n  private states: {[key: number]: TrafficSignalState};\r\n  private currentState: TrafficSignalState;\r\n\r\n  constructor (x: number, y: number, dir: number) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.dir = dir;\r\n    if (dir == 0) {\r\n      this.width = 10;\r\n      this.height = 30;\r\n    } else {\r\n      this.width = 30;\r\n      this.height = 10;\r\n    }\r\n    this.box = new Box(new Vector(this.x, this.y), this.width, this.height);\r\n\r\n    this.time = 0;\r\n    this.maxTime = 0;\r\n    this.states = {\r\n      [trafficSignalStates.GREEN]: new TrafficSignalGreen(this),\r\n      [trafficSignalStates.RED]: new TrafficSignalRed(this),\r\n      [trafficSignalStates.YELLOW]: new TrafficSignalYellow(this),\r\n    };\r\n    this.currentState = this.states[trafficSignalStates.GREEN];\r\n    this.setState(trafficSignalStates.GREEN);\r\n  }\r\n\r\n  draw (context: CanvasRenderingContext2D) {\r\n    context.fillStyle = '#1C1F1E';\r\n    context.fillRect(this.x, this.y, this.width, this.height);\r\n    if (this.dir == 0) {\r\n      const middle = this.height / 3 / 2;\r\n      const section = this.height / 3;\r\n      context.beginPath();\r\n      context.fillStyle = '#FE5E5A' + (this.currentState !instanceof TrafficSignalRed ? '' : '40');\r\n      context.arc(this.x + this.width / 2, this.y + (section * 0 + middle), 3, 0, 2 * Math.PI);\r\n      context.fill();\r\n      context.beginPath();\r\n      context.fillStyle = '#FEC957' + (this.currentState !instanceof TrafficSignalYellow ? '' : '40');\r\n      context.arc(this.x + this.width / 2, this.y + (section * 1 + middle), 3, 0, 2 * Math.PI);\r\n      context.fill();\r\n      context.beginPath();\r\n      context.fillStyle = '#2DCA5E' + (this.currentState !instanceof TrafficSignalGreen ? '' : '40');\r\n      context.arc(this.x + this.width / 2, this.y + (section * 2 + middle), 3, 0, 2 * Math.PI);\r\n      context.fill();\r\n    } else {\r\n      const middle = this.width / 3 / 2;\r\n      const section = this.width / 3;\r\n      context.beginPath();\r\n      context.fillStyle = '#FE5E5A' + (this.currentState !instanceof TrafficSignalRed ? '' : '40');\r\n      context.arc(this.x + (section * 0 + middle), this.y + this.height / 2, 3, 0, 2 * Math.PI);\r\n      context.fill();\r\n      context.beginPath();\r\n      context.fillStyle = '#FEC957' + (this.currentState !instanceof TrafficSignalYellow ? '' : '40');\r\n      context.arc(this.x + (section * 1 + middle), this.y + this.height / 2, 3, 0, 2 * Math.PI);\r\n      context.fill();\r\n      context.beginPath();\r\n      context.fillStyle = '#2DCA5E' + (this.currentState !instanceof TrafficSignalGreen ? '' : '40');\r\n      context.arc(this.x + (section * 2 + middle), this.y + this.height / 2, 3, 0, 2 * Math.PI);\r\n      context.fill();\r\n    }\r\n  }\r\n\r\n  update (deltaTime: number): void {\r\n    this.time += deltaTime;\r\n    if (this.time >= this.maxTime) {\r\n      this.currentState.next();\r\n    }\r\n  }\r\n\r\n  getBox (): Box|void {\r\n    return this.currentState instanceof TrafficSignalRed ? this.box : undefined;\r\n  }\r\n\r\n  setState (state: trafficSignalStates): void {\r\n    this.currentState = this.states[state];\r\n    this.currentState.enter();\r\n  }\r\n}","import Floor from \"./map/floor\";\r\nimport House from \"./map/house\";\r\nimport Map from \"./map/map\";\r\nimport Road, { Point } from \"./map/road\";\r\nimport Terrain from \"./map/terrain\";\r\nimport TrafficSignal from \"./map/trafficSignal\";\r\n\r\ntype TerrainAction = {type: \"wall\", props: {entranceDir: number}}\r\n  | {type: \"house\", props: {x: number, y: number, width: number, height: number, entranceDir: number}};\r\n\r\nexport default class MapBuilder {\r\n  private map: Map;\r\n\r\n  constructor () {\r\n    this.map = new Map();\r\n  }\r\n\r\n  public buildRoad (...points: Point[]): MapBuilder {\r\n    const road = new Road(points);\r\n    this.map.add(road);\r\n    return this;\r\n  }\r\n\r\n  public buildFloor (x: number, y: number, width: number, height: number, color: string): MapBuilder {\r\n    const floor = new Floor(x, y, width, height, color);\r\n    this.map.setFloor(floor);\r\n    return this;\r\n  }\r\n\r\n  public buildTrafficSignal (x: number, y: number, dir: number): MapBuilder {\r\n    const ts = new TrafficSignal(x, y, dir);\r\n    this.map.add(ts);\r\n    return this;\r\n  }\r\n\r\n  public buildTerrain (x: number, y: number, width: number, height: number, actions: TerrainAction[] = []): MapBuilder {\r\n    const terrain = new Terrain(x, y, width, height);\r\n    actions.forEach(({type, props}) => {\r\n      switch (type) {\r\n        case \"wall\":\r\n          terrain.addWall(props);\r\n          break;\r\n        case \"house\":\r\n          terrain.addHouse(props);\r\n          break;\r\n      }\r\n    });\r\n    this.map.add(terrain);\r\n    return this;\r\n  }\r\n\r\n  public buildHouse (x: number, y: number, width: number, height: number, entranceDir: number): MapBuilder {\r\n    const house = new House(x, y, width, height, entranceDir);\r\n    this.map.add(house);\r\n    return this;\r\n  }\r\n\r\n  public build (): Map {\r\n    return this.map;\r\n  }\r\n}\r\n","export function rotatePoint(x: number, y: number, degree: number): { x: number; y: number } {\r\n  const radian = (degree * Math.PI) / 180;\r\n  const newX = x * Math.cos(radian) - y * Math.sin(radian);\r\n  const newY = x * Math.sin(radian) + y * Math.cos(radian);\r\n  return { x: newX, y: newY };\r\n}\r\n","export default abstract class Particle {\r\n  protected x: number;\r\n  protected y: number;\r\n  protected size: number;\r\n  private speedX: number;\r\n  private speedY: number;\r\n  public markedForDeletion: boolean;\r\n\r\n  constructor (x: number, y: number) {\r\n    this.markedForDeletion = false;\r\n    this.x = x;\r\n    this.y = y;\r\n    this.size = Math.random() + 1;\r\n    this.speedX = Math.random();\r\n    this.speedY = Math.random();\r\n  }\r\n\r\n  update () {\r\n    this.x -= this.speedX;\r\n    this.y -= this.speedY;\r\n    this.size *= 1.025;\r\n    if (this.size > 5) this.markedForDeletion = true;\r\n  }\r\n\r\n  abstract draw (context: CanvasRenderingContext2D): void;\r\n}\r\n","import Particle from \"./particle\";\r\n\r\nexport default class Smoke extends Particle {\r\n  private color: string = '#FFFFFF40';\r\n\r\n  draw (context: CanvasRenderingContext2D) {\r\n    context.beginPath();\r\n    context.arc(this.x, this.y, this.size, 0, Math.PI * 2);\r\n    context.fillStyle = this.color;\r\n    context.fill();\r\n  }\r\n}","import Smoke from \"../particle/smoke\";\r\nimport Car from \"./car\";\r\n\r\nexport enum carStates { ON, OFF };\r\n\r\nexport abstract class CarState {\r\n  protected car: Car;\r\n  constructor (car: Car) {\r\n    this.car = car;\r\n  }\r\n\r\n  abstract update(input: string[], deltaTime: number): void;\r\n}\r\n\r\nexport class CarOnState extends CarState {\r\n  update(input: string[], deltaTime: number) {\r\n    this.car.game.addParticle(\r\n      new Smoke(\r\n        this.car.x - Math.cos((this.car.degree - 90) * (Math.PI / 180)) * (this.car.width * 0.2), // Posi√ß√£o X atr√°s do carro\r\n        this.car.y - Math.sin((this.car.degree - 90) * (Math.PI / 180)) * (this.car.width * 0.2), // Posi√ß√£o Y atr√°s do carro\r\n      )\r\n    );\r\n    //\r\n    if (input.includes('Backspace')) {\r\n      this.car.setState(carStates.OFF);\r\n    } \r\n    if (input.includes('ArrowUp')) {\r\n      if (this.car.speed < this.car.maxSpeed) {\r\n        this.car.speed += this.car.acceleration;\r\n      }\r\n    } else if (input.includes('ArrowDown')) {\r\n      if (this.car.speed > this.car.maxReverseSpeed) {\r\n        this.car.speed -= this.car.acceleration;\r\n      }\r\n    }\r\n\r\n    if (this.car.speed != 0) {\r\n      if (input.includes('ArrowRight')) {\r\n        this.car.degree += this.car.rotateSpeed * this.car.speed;\r\n      }\r\n\r\n      if (input.includes('ArrowLeft')) {\r\n        this.car.degree -= this.car.rotateSpeed * this.car.speed;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport class CarOffState extends CarState {\r\n  update(input: string[], deltaTime: number) {\r\n    if (input.includes('Enter')) {\r\n      this.car.setState(carStates.ON);\r\n    } \r\n  }\r\n}\r\n","import { Polygon, Vector } from \"sat\";\r\nimport Game from \"../game\";\r\nimport { rotatePoint } from \"../utils\";\r\nimport { CarOffState, CarOnState, CarState, carStates } from \"./carStates\";\r\n\r\nexport default class Car {\r\n  public game: Game;\r\n  private image: HTMLImageElement;\r\n  public x: number;\r\n  public y: number;\r\n  public width: number;\r\n  public height: number;\r\n  public degree: number;\r\n  public speed: number;\r\n  public maxSpeed: number;\r\n  public maxReverseSpeed: number;\r\n  public acceleration: number;\r\n  public resistance: number;\r\n  public rotateSpeed: number;\r\n\r\n  private states: {[key: number]: CarState};\r\n  public currentState: CarState;\r\n\r\n  constructor (game: Game, {x, y, degree}: {x: number, y: number, degree: number}) {\r\n    this.game = game;\r\n    this.x = x;\r\n    this.y = y;\r\n    this.degree = degree;\r\n    //\r\n    this.image = document.querySelector('#car') as HTMLImageElement;\r\n    this.width = this.image.width;\r\n    this.height = this.image.height;\r\n    //\r\n    this.speed = 0;\r\n    this.maxSpeed = 3;\r\n    this.maxReverseSpeed = -1;\r\n    this.acceleration = 0.05;\r\n    this.resistance = 0.02;\r\n    this.rotateSpeed = 0.75;\r\n    //\r\n    this.states = {\r\n      [carStates.ON]: new CarOnState(this),\r\n      [carStates.OFF]: new CarOffState(this),\r\n    };\r\n    this.currentState = this.states[carStates.OFF];\r\n  }\r\n\r\n  public update (input: string[], deltaTime: number) {\r\n    this.currentState.update(input, deltaTime);\r\n    //\r\n    if (this.speed > 0) {\r\n      this.speed -= this.resistance;\r\n      this.speed = Math.max(0, this.speed);\r\n    } else if (this.speed < 0) {\r\n      this.speed += this.resistance;\r\n      this.speed = Math.min(0, this.speed);\r\n    }\r\n    // Calcula a dire√ß√£o do movimento com base no grau\r\n    const radian = (this.degree - 90) * (Math.PI / 180);\r\n    const dx = Math.cos(radian) * this.speed;\r\n    const dy = Math.sin(radian) * this.speed;\r\n  \r\n    // Atualiza as coordenadas x e y para mover o carro\r\n    this.x += dx;\r\n    this.y += dy;\r\n  }\r\n\r\n  public draw (context: CanvasRenderingContext2D): void {\r\n    context.save();\r\n    context.translate(this.x, this.y);\r\n    context.rotate((Math.PI / 180) * this.degree);\r\n\r\n    context.drawImage(\r\n      this.image,\r\n      0,\r\n      0,\r\n      this.width,\r\n      this.height,\r\n      -this.width * 0.1,\r\n      -this.height * 0.1,\r\n      this.width * 0.2,\r\n      this.height * 0.2\r\n    );\r\n    context.restore();\r\n  }\r\n\r\n  get radian (): number {\r\n    return (this.degree - 90) * (Math.PI / 180);\r\n  }\r\n\r\n  public setState (state: carStates) {\r\n    this.currentState = this.states[state];\r\n  }\r\n\r\n  get polygon (): Polygon {\r\n    const topLeft = rotatePoint(\r\n      -this.width * 0.1,\r\n      -this.height * 0.1,\r\n      this.degree\r\n    );\r\n    const topRight = rotatePoint(\r\n      this.width * 0.1,\r\n      -this.height * 0.1,\r\n      this.degree\r\n    );\r\n    const bottomRight = rotatePoint(\r\n      this.width * 0.1,\r\n      this.height * 0.1,\r\n      this.degree\r\n    );\r\n    const bottomLeft = rotatePoint(\r\n      -this.width * 0.1,\r\n      this.height * 0.1,\r\n      this.degree\r\n    );\r\n\r\n    const points = [\r\n      new Vector(this.x + topLeft.x, this.y + topLeft.y),\r\n      new Vector(this.x + topRight.x, this.y + topRight.y),\r\n      new Vector(this.x + bottomRight.x, this.y + bottomRight.y),\r\n      new Vector(this.x + bottomLeft.x, this.y + bottomLeft.y)\r\n    ];\r\n\r\n    return new Polygon(new Vector(), points);\r\n  }\r\n}","import { Box, Vector, testPolygonPolygon } from \"sat\";\r\nimport Car from \"./car/car\";\r\nimport { CarOffState } from \"./car/carStates\";\r\n\r\nexport default class Goal {\r\n  private x: number;\r\n  private y: number;\r\n  public width: number;\r\n  public height: number;\r\n  private image: HTMLImageElement;\r\n  private box: Box;\r\n\r\n  constructor(x: number, y: number) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.image = document.querySelector('img#flag') as HTMLImageElement;\r\n    this.width = this.image.width;\r\n    this.height = this.image.height;\r\n    this.box = new Box(new Vector(x, y), this.width, this.height);\r\n  }\r\n\r\n  draw (context: CanvasRenderingContext2D): void {\r\n    context.drawImage(\r\n      this.image,\r\n      this.x,\r\n      this.y,\r\n      this.width,\r\n      this.height,\r\n    );\r\n  }\r\n\r\n  checkWin (car: Car): boolean {\r\n    return car.currentState instanceof CarOffState\r\n      && testPolygonPolygon(car.polygon, this.box.toPolygon());\r\n  }\r\n}","import \"./styles.css\";\r\n\r\nimport Game from \"./scripts/game\";\r\nimport MapBuilder from \"./scripts/mapBuilder\";\r\nimport Car from \"./scripts/car/car\";\r\nimport Goal from \"./scripts/goal\";\r\n\r\nwindow.addEventListener(\"load\", function () {\r\n  const canvas = document.querySelector(\"canvas\");\r\n  if (!canvas) return;\r\n  const context = canvas.getContext(\"2d\");\r\n  if (!context) return;\r\n  canvas.width = 1000;\r\n  canvas.height = 700;\r\n  //\r\n  const game = new Game(canvas.width, canvas.height);\r\n\r\n  const map = new MapBuilder()\r\n    .buildRoad({x: 0, y: 50}, {x: canvas.width, y: 50})\r\n    .buildRoad({x: 300, y: 92}, {x: 300, y: canvas.height})\r\n    .buildRoad({x: 342, y: 500}, {x: canvas.width, y: 500})\r\n    .buildRoad({x: 850, y: 458}, {x: 850, y: 300})\r\n    .buildHouse(670, 120, 300, 150, 0)\r\n    .buildTerrain(370, 120, 250, 200, [\r\n      {type: 'wall', props: {entranceDir: 3}},\r\n      {type: 'house', props: {x: 100, y: 25, width: 120, height: 150, entranceDir: 3}},\r\n    ])\r\n    .buildTerrain(10, 120, 220, 270, [\r\n      {type: 'house', props: {x: 10, y: 100, width: 200, height: 160, entranceDir: 1}},\r\n      {type: 'house', props: {x: 10, y: 10, width: 100, height: 60, entranceDir: 2}},\r\n    ])\r\n    .buildTerrain(10, 400, 220, 270, [\r\n      {type: 'house', props: {x: 10, y: 10, width: 200, height: 250, entranceDir: 1}},\r\n    ])\r\n    .buildTerrain(360, 560, 400, 400, [\r\n      {type: 'wall', props: {entranceDir: 4}},\r\n    ])\r\n    .buildFloor(0, 0, canvas.width, canvas.height, '#136d15')\r\n    .buildTrafficSignal(240, 56, 0)\r\n    .buildTrafficSignal(262, 446, 1)\r\n    .build();\r\n  const car = new Car(game, {x: 25, y: 72, degree: 90});\r\n  const goal = new Goal(860, 280);\r\n\r\n  game.setMap(map);\r\n  game.setCar(car);\r\n  game.setGoal(goal);\r\n\r\n  let lastTime = 0;\r\n  const animate = (timestamp: number):void => {\r\n    const deltaTime = timestamp - lastTime;\r\n    lastTime = timestamp;\r\n    context.clearRect(0, 0, canvas.width, canvas.height);\r\n    game.update(deltaTime);\r\n    game.draw(context);\r\n    if (!game.win && !game.gameOver) window.requestAnimationFrame(animate);\r\n  };\r\n  animate(0);\r\n});\r\n"]}